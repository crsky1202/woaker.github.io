<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>JDK各版本特性 | 每天都不一样</title><meta name="keywords" content="程序员"><meta name="author" content="woaker"><meta name="copyright" content="woaker"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言JDK 15发布啦~ 我们一起回顾JDK 5-15 的新特性吧，大家一起学习哈~ 本文已经收录到github  https:&#x2F;&#x2F;github.com&#x2F;whx123&#x2F;JavaHome  公众号：捡田螺的小男孩 Java 5 新特性 1. 泛型泛型本质是参数化类型，解决不确定具体对象类型的问题。 1List&lt;String&gt; strList&#x3D;new ArrayList&lt;String">
<meta property="og:type" content="article">
<meta property="og:title" content="JDK各版本特性">
<meta property="og:url" content="http://example.com/2022/06/19/JavaHome/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80%EF%BC%9AJDK%205-15%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BB%8F%E5%85%B8%E6%96%B0%E7%89%B9%E6%80%A7/index.html">
<meta property="og:site_name" content="每天都不一样">
<meta property="og:description" content="前言JDK 15发布啦~ 我们一起回顾JDK 5-15 的新特性吧，大家一起学习哈~ 本文已经收录到github  https:&#x2F;&#x2F;github.com&#x2F;whx123&#x2F;JavaHome  公众号：捡田螺的小男孩 Java 5 新特性 1. 泛型泛型本质是参数化类型，解决不确定具体对象类型的问题。 1List&lt;String&gt; strList&#x3D;new ArrayList&lt;String">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/image/4.jpeg">
<meta property="article:published_time" content="2022-06-19T13:50:08.138Z">
<meta property="article:modified_time" content="2022-06-20T14:23:14.347Z">
<meta property="article:author" content="woaker">
<meta property="article:tag" content="程序员">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/image/4.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/06/19/JavaHome/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80%EF%BC%9AJDK%205-15%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BB%8F%E5%85%B8%E6%96%B0%E7%89%B9%E6%80%A7/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JDK各版本特性',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-06-20 22:23:14'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">135</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/List"><i class="fa-fw fas fa-list"></i><span> Study</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/image/4.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">每天都不一样</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/List"><i class="fa-fw fas fa-list"></i><span> Study</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JDK各版本特性</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-06-19T13:50:08.138Z" title="发表于 2022-06-19 21:50:08">2022-06-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-06-20T14:23:14.347Z" title="更新于 2022-06-20 22:23:14">2022-06-20</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JDK各版本特性"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>JDK 15发布啦~ 我们一起回顾JDK 5-15 的新特性吧，大家一起学习哈~</p>
<p>本文已经收录到github</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/whx123/JavaHome">https://github.com/whx123/JavaHome</a></p>
</blockquote>
<p><strong>公众号：捡田螺的小男孩</strong></p>
<h3 id="Java-5-新特性"><a href="#Java-5-新特性" class="headerlink" title="Java 5 新特性"></a>Java 5 新特性</h3><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03f5d66e89bb4cd49e85fbfd795f204d~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h4 id="1-泛型"><a href="#1-泛型" class="headerlink" title="1. 泛型"></a>1. 泛型</h4><p>泛型本质是参数化类型，解决不确定具体对象类型的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strList=new ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure>
<h4 id="2-增强循环（for-each）"><a href="#2-增强循环（for-each）" class="headerlink" title="2. 增强循环（for-each）"></a>2. 增强循环（for-each）</h4><p>for-each循环简化了集合的遍历。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String [] str = &#123;&quot;关注&quot;,&quot;公众号&quot;,&quot;捡田螺的小男孩&quot;&#125;;</span><br><span class="line">for (String temp:str) &#123;</span><br><span class="line">     System.out.println(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-自动封箱拆箱"><a href="#3-自动封箱拆箱" class="headerlink" title="3. 自动封箱拆箱"></a>3. 自动封箱拆箱</h4><ul>
<li>自动装箱: 就是将基本数据类型自动转换成对应的包装类。</li>
<li>自动拆箱：就是将包装类自动转换成对应的基本数据类型。</li>
</ul>
<p>包装类型有：Integer,Double,Float,Long,Short,Character和Boolean</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i =666;  //自动装箱</span><br><span class="line">int a= i;     //自动拆箱</span><br></pre></td></tr></table></figure>

<h4 id="4-枚举"><a href="#4-枚举" class="headerlink" title="4. 枚举"></a>4. 枚举</h4><p>关键字enum可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用，这就是枚举类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum SeasonEnum &#123;</span><br><span class="line">    SPRING,SUMMER,FALL,WINTER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-可变参数"><a href="#5-可变参数" class="headerlink" title="5. 可变参数"></a>5. 可变参数</h4><p>我们在定义方法参数的时候不确定定义多少个，就可以定义为<strong>可变参数</strong>，它本质上是一个<strong>数组</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    String [] str = &#123;&quot;关注&quot;,&quot;公众号&quot;,&quot;捡田螺的小男孩&quot;&#125;;</span><br><span class="line">    testVarargs(str);</span><br><span class="line">    String str1 = &quot;关注公众号，捡田螺的小男孩&quot;;</span><br><span class="line">    testVarargs(str1);</span><br><span class="line">&#125;</span><br><span class="line">//可变参数String... args</span><br><span class="line">private static void testVarargs(String... args) &#123;</span><br><span class="line">    for (String arg : args) &#123;</span><br><span class="line">        System.out.println(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-注解"><a href="#6-注解" class="headerlink" title="6. 注解"></a>6. 注解</h4><p>可以把注解理解为代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.SOURCE)</span><br><span class="line">public @interface Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-静态导入"><a href="#7-静态导入" class="headerlink" title="7.静态导入"></a>7.静态导入</h4><p>通过import static类，就可以使用类里的静态变量或方法。看一下例子哈~</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import static java.lang.System.out; //静态导入System类的静态变量out</span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        String str1 = &quot;关注公众号，捡田螺的小男孩&quot;;</span><br><span class="line">        System.out.println(str1); //常规写法</span><br><span class="line">        out.println(str1);  //静态导入，可以直接使用out输出</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-线程并发库（JUC）"><a href="#8-线程并发库（JUC）" class="headerlink" title="8. 线程并发库（JUC）"></a>8. 线程并发库（JUC）</h4><p>JDK5 丰富了线程处理功能，java.util.concurrent包提供了以下的类、接口：</p>
<blockquote>
<ul>
<li>线程池：ExecutorService接口</li>
<li>线程护斥：Lock 类</li>
<li>线程通信：Condition接口</li>
<li>同步队列：ArrayBlockingQueue类</li>
<li>同步集合：ConcurrentHashMap类</li>
</ul>
</blockquote>
<h3 id="Java-6-新特性"><a href="#Java-6-新特性" class="headerlink" title="Java 6 新特性"></a>Java 6 新特性</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a91df99e8eb948e7a208d7222eb162cf~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h4 id="1-Desktop类和SystemTray类"><a href="#1-Desktop类和SystemTray类" class="headerlink" title="1.Desktop类和SystemTray类"></a>1.Desktop类和SystemTray类</h4><p>JDK 6在java.awt包下，新增了两个类：Desktop类和SystemTray类</p>
<blockquote>
<ul>
<li><strong>Desktop类</strong>: 用来打开系统默认浏览器浏览指定的URL,打开系统默认邮件客户端发邮件等</li>
<li><strong>SystemTray类</strong>:用来在系统托盘区创建一个托盘程序,如果在微软的Windows上，它被称为“任务栏”状态区域。</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//获取Desktop实例</span><br><span class="line">Desktop desktop = Desktop.getDesktop();</span><br><span class="line">desktop.browse(URI.create(&quot;https://www.baidu.com&quot;));</span><br></pre></td></tr></table></figure>

<h4 id="2-使用JAXB2来实现对象与XML之间的映射"><a href="#2-使用JAXB2来实现对象与XML之间的映射" class="headerlink" title="2. 使用JAXB2来实现对象与XML之间的映射"></a>2. 使用JAXB2来实现对象与XML之间的映射</h4><p> JAXB,即Java Architecture for XML Binding,可以实现对象与XML之间的映射，常用注解如下:</p>
<blockquote>
<ul>
<li>@XmlRootElement：注解在类上面，对应xml的跟元素，使用name属性定义根节点的名称。</li>
<li>@XmlElement：指定一个字段或get&#x2F;set方法映射到xml的节点，使用name属性定义这个根节点的名称。</li>
<li>@XmlAttribute：将JavaBean对象的属性映射为xml的属性,使用name属性为生成的xml属性指定别名。</li>
<li>@XmlAccessorType:定义映射这个类中的何种类型都需要映射到xml。</li>
<li>@XmlSchema: 将包映射到XML名称空间</li>
</ul>
</blockquote>
<p><strong>看个例子吧~</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class JAXB2XmlTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws JAXBException, IOException &#123;</span><br><span class="line">        </span><br><span class="line">        List&lt;Singer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(new Singer(&quot;jay&quot;, 8));</span><br><span class="line">        list.add(new Singer(&quot;eason&quot;, 10));</span><br><span class="line"></span><br><span class="line">        SingerList singerList = new SingerList();</span><br><span class="line">        singerList.setSingers(list);</span><br><span class="line"></span><br><span class="line">        String str = JAXB2XmlTest.beanToXml(singerList, SingerList.class);</span><br><span class="line">        String path = &quot;C:\\jay.txt&quot;;</span><br><span class="line">        BufferedWriter bfw = new BufferedWriter(new FileWriter(new File(path)));</span><br><span class="line">        bfw.write(str);</span><br><span class="line">        bfw.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static String beanToXml(Object obj, Class&lt;?&gt; load) throws JAXBException &#123;</span><br><span class="line">        JAXBContext context = JAXBContext.newInstance(load);</span><br><span class="line">        Marshaller marshaller = context.createMarshaller();</span><br><span class="line">        marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);</span><br><span class="line">        marshaller.setProperty(Marshaller.JAXB_ENCODING, &quot;GBK&quot;);</span><br><span class="line">        StringWriter writer = new StringWriter();</span><br><span class="line">        marshaller.marshal(obj,writer);</span><br><span class="line">        return writer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Singer &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    public Singer(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    @XmlAttribute(name=&quot;name&quot;)</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    @XmlAttribute(name=&quot;age&quot;)</span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@XmlRootElement(name=&quot;list&quot;)</span><br><span class="line">public class SingerList &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;Singer&gt; singers;</span><br><span class="line">    </span><br><span class="line">    @XmlElement(name=&quot;singer&quot;)</span><br><span class="line">    public List&lt;Singer&gt; getSingers() &#123;</span><br><span class="line">        return singers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSingers(List&lt;Singer&gt; singers) &#123;</span><br><span class="line">        this.singers = singers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行效果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;GBK&quot; standalone=&quot;yes&quot;?&gt;</span><br><span class="line">&lt;list&gt;</span><br><span class="line">    &lt;singer age=&quot;8&quot; name=&quot;jay&quot;/&gt;</span><br><span class="line">    &lt;singer age=&quot;10&quot; name=&quot;eason&quot;/&gt;</span><br><span class="line">&lt;/list&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-轻量级-Http-Server-API"><a href="#3-轻量级-Http-Server-API" class="headerlink" title="3.轻量级 Http Server API"></a>3.轻量级 Http Server API</h4><p>JDK 6中提供了简单的Http Server API，可以构建嵌入式Http服务器,同时支持Http和Https协议。HttpServer会调用HttpHandler实现类的回调方法来处理客户端请求,这里用户只需实现HttpHandler接口就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据Java提供的API实现Http服务器</span><br><span class="line"> */</span><br><span class="line">public class MyHttpServer &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param args</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        //创建HttpServer服务器</span><br><span class="line">        HttpServer httpServer = HttpServer.create(new InetSocketAddress(8080), 10);</span><br><span class="line">        //将 /jay请求交给MyHandler处理器处理</span><br><span class="line">        httpServer.createContext(&quot;/&quot;, new MyHandler());</span><br><span class="line">        httpServer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyHandler implements HttpHandler &#123;</span><br><span class="line"></span><br><span class="line">    public void handle(HttpExchange httpExchange) throws IOException &#123;</span><br><span class="line">        //请求头</span><br><span class="line">        Headers headers = httpExchange.getRequestHeaders();</span><br><span class="line">        Set&lt;Map.Entry&lt;String, List&lt;String&gt;&gt;&gt; entries = headers.entrySet();</span><br><span class="line"></span><br><span class="line">        StringBuffer response = new StringBuffer();</span><br><span class="line">        for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry : entries)&#123;</span><br><span class="line">            response.append(entry.toString() + &quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //设置响应头属性及响应信息的长度</span><br><span class="line">        httpExchange.sendResponseHeaders(200, response.length());</span><br><span class="line">        //获得输出流</span><br><span class="line">        OutputStream os = httpExchange.getResponseBody();</span><br><span class="line">        os.write(response.toString().getBytes());</span><br><span class="line">        os.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-插入式注解处理API"><a href="#4-插入式注解处理API" class="headerlink" title="4. 插入式注解处理API"></a>4. 插入式注解处理API</h4><blockquote>
<p>JDK 6提供了插入式注解处理API，可以让我们定义的注解在编译期而不是运行期生效，从而可以在编译期修改字节码。lombok框架就是使用该特性来实现的，Lombok通过注解的方式，在编译时自动为属性生成构造器、getter&#x2F;setter、equals、hashcode、toString等方法，大大简化了代码的开发。</p>
</blockquote>
<h4 id="5-STAX"><a href="#5-STAX" class="headerlink" title="5. STAX"></a>5. STAX</h4><p>STAX，是JDK6中一种处理XML文档的API。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class STAXTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();</span><br><span class="line">        XMLEventReader xmlEventReader = xmlInputFactory.createXMLEventReader(new FileInputStream(&quot;C:\\jay.xml&quot;));</span><br><span class="line">        XMLEvent event = null;</span><br><span class="line">        StringBuffer stringBuffer = new StringBuffer();</span><br><span class="line">        while (xmlEventReader.hasNext()) &#123;</span><br><span class="line">            event = xmlEventReader.nextEvent();</span><br><span class="line">            stringBuffer.append(event.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;xml文档解析结果：&quot;);</span><br><span class="line">        System.out.println(stringBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xml文档解析结果：</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&#x27;GBK&#x27; standalone=&#x27;yes&#x27;?&gt;&lt;list&gt;</span><br><span class="line">    &lt;singer name=&#x27;jay&#x27; age=&#x27;8&#x27;&gt;&lt;/singer&gt;</span><br><span class="line">    &lt;singer name=&#x27;eason&#x27; age=&#x27;10&#x27;&gt;&lt;/singer&gt;</span><br><span class="line">&lt;/list&gt;ENDDOCUMENT</span><br></pre></td></tr></table></figure>

<h4 id="6-Common-Annotations"><a href="#6-Common-Annotations" class="headerlink" title="6. Common Annotations"></a>6. Common Annotations</h4><blockquote>
<p>Common annotations原本是Java EE 5.0(JSR 244)规范的一部分，现在SUN把它的一部分放到了Java SE 6.0中。随着Annotation元数据功能加入到Java SE 5.0里面，很多Java 技术都会用Annotation部分代替XML文件来配置运行参数。</p>
</blockquote>
<p> 以下列举Common Annotations 1.0里面的几个Annotations:</p>
<ul>
<li>@Generated：用于标注生成的源代码</li>
<li>@Resource： 用于标注所依赖的资源，容器据此注入外部资源依赖，有基于字段的注入和基于setter方法的注入两种方式 。</li>
<li>@Resources：同时标注多个外部依赖，容器会把所有这些外部依赖注入</li>
<li>@PostConstruct：标注当容器注入所有依赖之后运行的方法，用来进行依赖注入后的初始化工作，只有一个方法可以标注为PostConstruct 。</li>
<li>@PreDestroy：当对象实例将要被从容器当中删掉之前，要执行的回调方法要标注为PreDestroy</li>
</ul>
<h4 id="7-Compiler-API"><a href="#7-Compiler-API" class="headerlink" title="7. Compiler API"></a>7. Compiler API</h4><p>javac编译器可以把.java的源文件编译为.class文件，JDK 6的新特性Compiler API(JSR 199)也可以动态编译Java源文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class CompilerApiTest &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler();</span><br><span class="line">        StandardJavaFileManager standardJavaFileManager = javaCompiler.getStandardFileManager(null,null,null);</span><br><span class="line">        Iterable&lt;? extends JavaFileObject&gt; javaFileObjects = standardJavaFileManager.getJavaFileObjects(&quot;C:\\Singer.java&quot;);</span><br><span class="line">        javaCompiler.getTask(null, standardJavaFileManager, null, null, null, javaFileObjects).call();</span><br><span class="line">        standardJavaFileManager.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：会在C目录生成Singer.class文件</p>
<h4 id="8-对脚本语言的支持（如-ruby-groovy-javascript）"><a href="#8-对脚本语言的支持（如-ruby-groovy-javascript）" class="headerlink" title="8. 对脚本语言的支持（如: ruby, groovy, javascript）"></a>8. 对脚本语言的支持（如: ruby, groovy, javascript）</h4><p>JDK6增加了对脚本语言的支持(JSR 223)，原理是将脚本语言编译成字节码，这样脚本语言也能享用Java平台的诸多优势，包括可移植性，安全等。JDK6实现包含了一个基于Mozilla Rhino的 脚本语言引擎,因此可以支持javascript，当然JDK也支持ruby等其他语言</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class JavaScriptTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ScriptEngineManager factory = new ScriptEngineManager();</span><br><span class="line">        ScriptEngine engine = factory.getEngineByName(&quot;JavaScript&quot;);</span><br><span class="line">        String script;</span><br><span class="line">        try &#123;</span><br><span class="line">            script = &quot;print(&#x27;Hello&#x27;)&quot;;</span><br><span class="line">            engine.eval(script);// 执行脚本</span><br><span class="line">        &#125;catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//output</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure>
<h3 id="Java-7-新特性"><a href="#Java-7-新特性" class="headerlink" title="Java 7 新特性"></a>Java 7 新特性</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c52833f0793f4c0fadf77f172b016912~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h4 id="1-switch-支持String字符串类型。"><a href="#1-switch-支持String字符串类型。" class="headerlink" title="1.switch 支持String字符串类型。"></a>1.switch 支持String字符串类型。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String singer = &quot;jay&quot;;</span><br><span class="line">switch (singer) &#123;</span><br><span class="line">       case &quot;jay&quot; :</span><br><span class="line">            System.out.println(&quot;周杰伦&quot;);</span><br><span class="line">             break;</span><br><span class="line">       case &quot;eason&quot; :</span><br><span class="line">            System.out.println(&quot;陈奕迅&quot;);</span><br><span class="line">            break ;</span><br><span class="line">       default :</span><br><span class="line">            System.out.println(&quot;其他&quot;);</span><br><span class="line">            break ;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-try-with-resources，资源自动关闭"><a href="#2-try-with-resources，资源自动关闭" class="headerlink" title="2.try-with-resources，资源自动关闭"></a>2.try-with-resources，资源自动关闭</h4><p>JDK 7 之前:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader br = new BufferedReader(new FileReader(&quot;d:七里香.txt&quot;));</span><br><span class="line">try &#123;</span><br><span class="line">   return br.readLine();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">   br.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK 7 之后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 声明在try括号中的对象称为资源，在方法执行完毕后会被自动关闭</span><br><span class="line"> */</span><br><span class="line">try (BufferedReader br = new BufferedReader(new FileReader(&quot;d:七里香.txt&quot;)) &#123;</span><br><span class="line">   return br.readLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-整数类型如（byte，short，int，long）能够用二进制来表示"><a href="#3-整数类型如（byte，short，int，long）能够用二进制来表示" class="headerlink" title="3. 整数类型如（byte，short，int，long）能够用二进制来表示"></a>3. 整数类型如（byte，short，int，long）能够用二进制来表示</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//0b或者0B表示二进制</span><br><span class="line">int a = 0b010;</span><br><span class="line">int b = 0B010;</span><br></pre></td></tr></table></figure>
<h4 id="4-数字常量支持下划线"><a href="#4-数字常量支持下划线" class="headerlink" title="4. 数字常量支持下划线"></a>4. 数字常量支持下划线</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a = 11_11;//a的值为1111，下划线不影响实际值，提升可读性</span><br></pre></td></tr></table></figure>

<h4 id="5-泛型实例化类型自动推断-即”-lt-gt-”"><a href="#5-泛型实例化类型自动推断-即”-lt-gt-”" class="headerlink" title="5. 泛型实例化类型自动推断,即”&lt;&gt;”"></a>5. 泛型实例化类型自动推断,即”&lt;&gt;”</h4><p>JDK 7 之前：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;();</span><br></pre></td></tr></table></figure>
<p>JDK 7之后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//不须声明类型,自动根据前面&lt;&gt;推断其类型</span><br><span class="line">Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h4 id="6-一个catch中捕获多个异常类型，用（-）分隔开"><a href="#6-一个catch中捕获多个异常类型，用（-）分隔开" class="headerlink" title="6.一个catch中捕获多个异常类型，用（|）分隔开"></a>6.一个catch中捕获多个异常类型，用（|）分隔开</h4><p>JDK 7之前</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">   //do something</span><br><span class="line">&#125; catch (FirstException e) &#123;</span><br><span class="line">     logger.error(e);</span><br><span class="line">&#125; catch (SecondException e) &#123;</span><br><span class="line">     logger.error(ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDk 7之后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">   //do something</span><br><span class="line">&#125; catch (FirstException | SecondException e) &#123;</span><br><span class="line">     logger.error(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-增强的文件系统"><a href="#7-增强的文件系统" class="headerlink" title="7. 增强的文件系统"></a>7. 增强的文件系统</h4><p>Java7 提供了全新的NIO2.0 API，方便文件管理的编码。如，可以在java.nio.file包下使用Path、Paths、Files、WatchService等常用类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(&quot;C:\\jay\\七里香.txt&quot;); //创建Path对象</span><br><span class="line">byte[] bytes= Files.readAllBytes(path);  //读取文件</span><br><span class="line">System.out.println(path.getFileName()); //获取当前文件名称</span><br><span class="line">System.out.println(path.toAbsolutePath()); // 获取文件绝对路径</span><br><span class="line">System.out.println(new String(bytes, &quot;utf-8&quot;));</span><br></pre></td></tr></table></figure>

<h4 id="8-Fork-x2F-join-框架"><a href="#8-Fork-x2F-join-框架" class="headerlink" title="8. Fork&#x2F;join 框架"></a>8. Fork&#x2F;join 框架</h4><p>Java7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/823a548cf6d64cedb1dd507c5234788f~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>Fork&#x2F;join计算1-1000累加值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class ForkJoinPoolTest &#123;</span><br><span class="line"></span><br><span class="line">    private static final Integer DURATION_VALUE = 100;</span><br><span class="line"></span><br><span class="line">    static class ForkJoinSubTask extends RecursiveTask&lt;Integer&gt;&#123;</span><br><span class="line"></span><br><span class="line">        // 子任务开始计算的值</span><br><span class="line">        private Integer startValue;</span><br><span class="line">        // 子任务结束计算的值</span><br><span class="line">        private Integer endValue;</span><br><span class="line"></span><br><span class="line">        private ForkJoinSubTask(Integer startValue , Integer endValue) &#123;</span><br><span class="line">            this.startValue = startValue;</span><br><span class="line">            this.endValue = endValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected Integer compute() &#123;</span><br><span class="line">            //小于一定值DURATION,才开始计算</span><br><span class="line">            if(endValue - startValue &lt; DURATION_VALUE) &#123;</span><br><span class="line">                System.out.println(&quot;执行子任务计算：开始值 = &quot; + startValue + &quot;;结束值 = &quot; + endValue);</span><br><span class="line">                Integer totalValue = 0;</span><br><span class="line">                for (int index = this.startValue; index &lt;= this.endValue; index++) &#123;</span><br><span class="line">                    totalValue += index;</span><br><span class="line">                &#125;</span><br><span class="line">                return totalValue;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 将任务拆分，拆分成两个任务</span><br><span class="line">                ForkJoinSubTask subTask1 = new ForkJoinSubTask(startValue, (startValue + endValue) / 2);</span><br><span class="line">                subTask1.fork();</span><br><span class="line">                ForkJoinSubTask subTask2 = new ForkJoinSubTask((startValue + endValue) / 2 + 1 , endValue);</span><br><span class="line">                subTask2.fork();</span><br><span class="line">                return subTask1.join() + subTask2.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        // Fork/Join框架的线程池</span><br><span class="line">        ForkJoinPool pool = new ForkJoinPool();</span><br><span class="line">        ForkJoinTask&lt;Integer&gt; taskFuture =  pool.submit(new ForkJoinSubTask(1,1000));</span><br><span class="line"></span><br><span class="line">        Integer result = taskFuture.get();</span><br><span class="line">        System.out.println(&quot;累加结果是:&quot; + result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">执行子任务计算：开始值 = 189;结束值 = 250</span><br><span class="line">执行子任务计算：开始值 = 251;结束值 = 313</span><br><span class="line">执行子任务计算：开始值 = 314;结束值 = 375</span><br><span class="line">执行子任务计算：开始值 = 376;结束值 = 438</span><br><span class="line">执行子任务计算：开始值 = 439;结束值 = 500</span><br><span class="line">执行子任务计算：开始值 = 501;结束值 = 563</span><br><span class="line">执行子任务计算：开始值 = 564;结束值 = 625</span><br><span class="line">执行子任务计算：开始值 = 626;结束值 = 688</span><br><span class="line">执行子任务计算：开始值 = 689;结束值 = 750</span><br><span class="line">执行子任务计算：开始值 = 751;结束值 = 813</span><br><span class="line">执行子任务计算：开始值 = 814;结束值 = 875</span><br><span class="line">执行子任务计算：开始值 = 876;结束值 = 938</span><br><span class="line">执行子任务计算：开始值 = 939;结束值 = 1000</span><br><span class="line">累加结果是:500500</span><br></pre></td></tr></table></figure>

<h3 id="Java-8-新特性"><a href="#Java-8-新特性" class="headerlink" title="Java 8 新特性"></a>Java 8 新特性</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5730671f3ef344bd89163eb4a3f9f710~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h4 id="1-lambada表达式"><a href="#1-lambada表达式" class="headerlink" title="1.lambada表达式"></a>1.lambada表达式</h4><p>Lambda 允许把函数作为一个方法的参数，传递到方法中</p>
<p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression 或 (parameters) -&gt;&#123; statements; &#125;</span><br></pre></td></tr></table></figure>
<p>代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList(&quot;jay&quot;, &quot;Eason&quot;, &quot;SHE&quot;).forEach(</span><br><span class="line">       ( String singer ) -&gt; System.out.print( singer + &quot;,&quot;) );</span><br></pre></td></tr></table></figure>

<h4 id="2-函数式接口"><a href="#2-函数式接口" class="headerlink" title="2. 函数式接口"></a>2. 函数式接口</h4><p>Lambda的设计者为了让现有的功能与Lambda表达式很好兼容，设计出函数式接口。</p>
<ul>
<li>函数式接口是指只有一个函数的接口，可以隐式转换为lambada表达式。</li>
<li>Java 8 提供了注解@FunctionalInterface，显示声明一个函数式接口。</li>
<li>java.lang.Runnable和java.util.concurrent.Callable是函数式接口的例子~</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Runnable &#123;</span><br><span class="line">    public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-方法引用"><a href="#3-方法引用" class="headerlink" title="3. 方法引用"></a>3. 方法引用</h4><p>方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。它与Lambda表达式配合使用，可以减少冗余代码，使代码更加简洁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//利用函数式接口Consumer的accept方法实现打印，Lambda表达式如下</span><br><span class="line">Consumer&lt;String&gt; consumer = x -&gt; System.out.println(x);</span><br><span class="line">consumer.accept(&quot;jay&quot;);</span><br><span class="line">//引用PrintStream类（也就是System.out的类型）的println方法，这就是方法引用</span><br><span class="line">consumer = System.out::println;</span><br><span class="line">consumer.accept(&quot;关注公众号捡田螺的小男孩&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="4-默认方法"><a href="#4-默认方法" class="headerlink" title="4. 默认方法"></a>4. 默认方法</h4><p> 默认方法就是一个在接口里面有了一个实现的方法。它允许将新方法添加到接口，但不强制实现了该接口的类必须实现新的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface ISingerService &#123;</span><br><span class="line">    // 默认方法</span><br><span class="line">    default void sing()&#123;</span><br><span class="line">        System.out.println(&quot;唱歌&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    void writeSong();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//JaySingerServiceImpl 不用强制实现ISingerService的默认sing()方法</span><br><span class="line">public class JaySingerServiceImpl implements ISingerService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void writeSong() &#123;</span><br><span class="line">        System.out.println(&quot;写了一首七里香&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-Stream-API"><a href="#5-Stream-API" class="headerlink" title="5.Stream API"></a>5.Stream API</h4><p>Stream API，支持对元素流进行函数式操作，它集成在Collections API 中，可以对集合进行批量操作。常用API：</p>
<ul>
<li>filter 筛选</li>
<li>map流映射</li>
<li>reduce 将流中的元素组合起来</li>
<li>collect 返回集合</li>
<li>sorted 排序</li>
<li>flatMap 流转换</li>
<li>limit返回指定流个数</li>
<li>distinct去除重复元素<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Singer &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private Integer songNum;</span><br><span class="line">    private Integer age;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Singer&gt; singerList = new ArrayList&lt;Singer&gt;();</span><br><span class="line">singerList.add(new Singer(&quot;jay&quot;, 11, 36));</span><br><span class="line">singerList.add(new Singer(&quot;eason&quot;, 8, 31));</span><br><span class="line">singerList.add(new Singer(&quot;JJ&quot;, 6, 29));</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; singerNameList = singerList.stream()</span><br><span class="line">                .filter(singer -&gt; singer.getAge() &gt; 30)  //筛选年龄大于30</span><br><span class="line">                .sorted(Comparator.comparing(Singer::getSongNum))  //根据歌曲数量排序</span><br><span class="line">                .map(Singer::getName)  //提取歌手名字</span><br><span class="line">                .collect(Collectors.toList()); //转换为List</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="6-Optional"><a href="#6-Optional" class="headerlink" title="6. Optional"></a>6. Optional</h4><p> Java 8引入Optional类，用来解决NullPointerException。Optional代替if…else解决空指针问题，使代码更加简洁。</p>
<p>if…else 判空</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Singer singer = getSingerById(&quot;666&quot;);</span><br><span class="line">if (singer != null) &#123;</span><br><span class="line">    String name  = singer.getName();</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Optional的判空</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Singer&gt; singer = Optional.ofNullable(getSingerById(&quot;666&quot;));</span><br><span class="line">singer.ifPresent(s -&gt; System.out.println(s.getName()));</span><br></pre></td></tr></table></figure>

<h4 id="7-Date-Time-API"><a href="#7-Date-Time-API" class="headerlink" title="7. Date Time API"></a>7. Date Time API</h4><p>JDK 8之前的日期API处理存在非线程安全、时区处理麻烦等问题。Java 8 在 java.time包下提供了新的日期API，简化了日期的处理~</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">int year = today.getYear();</span><br><span class="line">System.out.println(&quot;今年是&quot; + year);</span><br><span class="line">//是否闰年</span><br><span class="line">System.out.println(&quot;今年是不是闰年:&quot; + today.isLeapYear());</span><br><span class="line"></span><br><span class="line">LocalDateTime todayTime = LocalDateTime.now();</span><br><span class="line">System.out.println(&quot;当前时间&quot; + todayTime);</span><br><span class="line">//时区指定</span><br><span class="line">System.out.println(&quot;美国时间:&quot; + ZonedDateTime.of(todayTime,ZoneId.of(&quot;America/Los_Angeles&quot;)));</span><br><span class="line">        </span><br><span class="line">LocalDate specailDate = LocalDate.of(2020, 6, 20);</span><br><span class="line">LocalDate expectDate = specailDate.plus(100, ChronoUnit.DAYS);</span><br><span class="line">System.out.println(&quot;比较特别的一天&quot; + specailDate);</span><br><span class="line">System.out.println(&quot;特殊日期的100天&quot; + expectDate);</span><br></pre></td></tr></table></figure>

<h4 id="8-重复注解"><a href="#8-重复注解" class="headerlink" title="8. 重复注解"></a>8. 重复注解</h4><p>重复注解，即一个注解可以在一个类、属性或者方法上同时使用多次；用@Repeatable定义重复注解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Repeatable(ScheduleTimes.class)</span><br><span class="line">public @interface ScheduleTime &#123;</span><br><span class="line">    String value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public @interface ScheduleTimes &#123;</span><br><span class="line">    ScheduleTime[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ScheduleTimeTask &#123;</span><br><span class="line">    @ScheduleTime(&quot;10&quot;)</span><br><span class="line">    @ScheduleTime(&quot;12&quot;)</span><br><span class="line">    public void doSomething() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-Base64"><a href="#9-Base64" class="headerlink" title="9. Base64"></a>9. Base64</h4><p>Java 8把Base64编码的支持加入到官方库中~</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;公众号:捡田螺的小男孩&quot;;</span><br><span class="line">String encoded = Base64.getEncoder().encodeToString(str.getBytes( StandardCharsets.UTF_8));</span><br><span class="line">String decoded = new String(Base64.getDecoder().decode(encoded), StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure>

<h4 id="10-JVM的新特性"><a href="#10-JVM的新特性" class="headerlink" title="10. JVM的新特性"></a>10. JVM的新特性</h4><p>使用元空间Metaspace代替持久代（PermGen space），JVM参数使用-XX:MetaSpaceSize和-XX:MaxMetaspaceSize设置大小。</p>
<h3 id="Java-9-新特性"><a href="#Java-9-新特性" class="headerlink" title="Java 9 新特性"></a>Java 9 新特性</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b0457ff711b412094b2900ba4b4e974~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h4 id="1-java模块系统"><a href="#1-java模块系统" class="headerlink" title="1. java模块系统"></a>1. java模块系统</h4><p>什么是模块化？</p>
<blockquote>
<p>一个大型系统，比如一个商城网站，它会包含很多模块的，如：订单模块，用户信息模块，商品信息模块，广告位模块等等。各个模块之间会相互调用。如果每个模块单独运行都会带动其他所有模块，性能非常低效。但是，如果某一模块运行时，只会启动它所依赖的模块，性能大大提升。这就是JDK 9模块化的思想。</p>
</blockquote>
<p>什么是JDK 9模块化？</p>
<blockquote>
<p> Java 平台模块系统，即Project Jigsaw，把模块化开发实践引入到了Java平台中。在引入了模块系统之后，JDK 被重新组织成94个模块。Java 应用可以通过新增的jlink 工具，创建出只包含所依赖的JDK模块的自定义运行时镜像。这样可以极大的减少Java运行时环境的大小。</p>
</blockquote>
<p>Java 9 模块的重要特征：</p>
<blockquote>
<ul>
<li>在其工件（artifact）的根目录中包含了一个描述模块的 module-info.class 文 件。 </li>
<li>工件的格式可以是传统的 JAR 文件或是 Java 9 新增的 JMOD 文件。</li>
<li>这个文件由根目录中的源代码文件 module-info.java 编译而来。</li>
<li>该模块声明文件可以描述模块的不同特征。</li>
</ul>
</blockquote>
<p>在 module-info.java 文件中，我们可以用新的关键词module来声明一个模块，如下所示。下面给出了一个模块com.mycompany.mymodule的最基本的模块声明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module com.jay.sample &#123;   //关键词module来声明一个模块</span><br><span class="line">    exports com.jay.sample; //使用 exports可以声明模块对其他模块所导出的包。</span><br><span class="line">    requires com.jay.common; //使用requires可以声明模块对其他模块的依赖关系。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-不可变集合工厂方法"><a href="#2-不可变集合工厂方法" class="headerlink" title="2. 不可变集合工厂方法"></a>2. 不可变集合工厂方法</h4><p>为了创建不可变集合，JDK9之前酱紫的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringList = new ArrayList&lt;&gt;();</span><br><span class="line">stringList.add(&quot;关注公众号:&quot;);</span><br><span class="line">stringList.add(&quot;捡田螺的小男孩&quot;);</span><br><span class="line">List&lt;String&gt; unmodifiableList = Collections.unmodifiableList(stringList);</span><br></pre></td></tr></table></figure>
<p>JDK 9 提供了List.of()、Set.of()、Map.of()和Map.ofEntries()等工厂方法来创建不可变集合：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; unmodifiableList = List.of(&quot;关注公众号:&quot;,&quot;捡田螺的小男孩&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="3-接口支持私有方法"><a href="#3-接口支持私有方法" class="headerlink" title="3. 接口支持私有方法"></a>3. 接口支持私有方法</h4><p>JDK 8支持在接口实现默认方法和静态方法，但是不能在接口中创建私有方法，为了避免了代码冗余和提高阅读性，JDK 9在接口中支持私有方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public interface IPrivateInterfaceTest &#123;</span><br><span class="line"></span><br><span class="line">    //JDK 7 之前</span><br><span class="line">    String a = &quot;jay&quot;;</span><br><span class="line">    void method7();</span><br><span class="line"></span><br><span class="line">    //JDK 8</span><br><span class="line">    default void methodDefault8()&#123;</span><br><span class="line">        System.out.println(&quot;JDK 8新特性默认方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    static void methodStatic8() &#123;</span><br><span class="line">        System.out.println(&quot;JDk 8新特性静态方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //Java 9 接口支持私有方法</span><br><span class="line">    private void method9()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-钻石操作符升级"><a href="#4-钻石操作符升级" class="headerlink" title="4.  钻石操作符升级"></a>4.  钻石操作符升级</h4><ul>
<li>钻石操作符是在 java 7 中引入的，可以让代码更易读，但它不能用于匿名的内部类。</li>
<li>在 java 9 中， 它可以与匿名的内部类一起使用，从而提高代码的可读性。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//JDK 5,6</span><br><span class="line">Map&lt;String, String&gt; map56 = new HashMap&lt;String,String&gt;();</span><br><span class="line">//JDk 7,8</span><br><span class="line">Map&lt;String, String&gt; map78 = new HashMap&lt;&gt;();</span><br><span class="line">//JDK 9 结合匿名内部类的实现</span><br><span class="line">Map&lt;String, String&gt; map9 = new HashMap&lt;&gt;()&#123;&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5-Optional-类改进"><a href="#5-Optional-类改进" class="headerlink" title="5. Optional 类改进"></a>5. Optional 类改进</h4><p> java 9 中，java.util.Optional 添加了很多新的有用方法，如：</p>
<ul>
<li>stream()</li>
<li>ifPresentOrElse()</li>
<li>or()</li>
</ul>
<p>ifPresentOrElse 方法的改进就是有了 else，接受两个参数 Consumer 和 Runnable。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Optional;</span><br><span class="line"> </span><br><span class="line">public class OptionalTest &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Optional&lt;Integer&gt; optional = Optional.of(1);</span><br><span class="line"> </span><br><span class="line">      optional.ifPresentOrElse( x -&gt; System.out.println(&quot;Value: &quot; + x),() -&gt; </span><br><span class="line">         System.out.println(&quot;Not Present.&quot;));</span><br><span class="line"> </span><br><span class="line">      optional = Optional.empty();</span><br><span class="line"> </span><br><span class="line">      optional.ifPresentOrElse( x -&gt; System.out.println(&quot;Value: &quot; + x),() -&gt; </span><br><span class="line">         System.out.println(&quot;Not Present.&quot;));</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-多版本兼容Jar包"><a href="#6-多版本兼容Jar包" class="headerlink" title="6. 多版本兼容Jar包"></a>6. 多版本兼容Jar包</h4><blockquote>
<p>很多公司使用的JDK都是老版本的，JDK6、JDk5 ，甚至JDk4的，不是他们不想升级JDk版本，而是担心兼容性问题。JDK 9的一个新特性，多版本兼容Jar包解决了这个问题。举个例子：假设你一直用的是小米8，已经非常习惯它的运行流程了，突然出来小米9，即使小米9很多新功能引人入胜，但是有些人不会轻易买小米9，因为已经已经习惯小米8的流程。同理，为什么很多公司不升级JDK，就是在此。但是呢，JDK 9的这个功能很强大，它可以让你的版本升级到JDK 9，但是还是老版本的运行流程，即在老的运行流程继承新的功能~</p>
</blockquote>
<h4 id="7-JShell工具"><a href="#7-JShell工具" class="headerlink" title="7. JShell工具"></a>7. JShell工具</h4><p>jShell工具相当于cmd工具，然后呢，你可以像在cmd工具操作一样，直接在上面运行Java方法，Java语句等~</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; System.out.println(&quot;关注公众号：捡田螺的小男孩&quot;);</span><br><span class="line">关注公众号：捡田螺的小男孩</span><br></pre></td></tr></table></figure>

<h4 id="8-try-with-resources的改进"><a href="#8-try-with-resources的改进" class="headerlink" title="8. try-with-resources的改进"></a>8. try-with-resources的改进</h4><p>JDK 9对try-with-resources异常处理机制进行了升级~</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//JDK 7,8</span><br><span class="line">try (BufferedReader br = new BufferedReader(new FileReader(&quot;d:七里香.txt&quot;)) &#123;</span><br><span class="line">   br.readLine();</span><br><span class="line">&#125;catch(IOException e)&#123;</span><br><span class="line">  log.error(&quot;IO 异常，e:&#123;&#125;&quot;,e);</span><br><span class="line">&#125;</span><br><span class="line">//JDk 9</span><br><span class="line">BufferedReader br = new BufferedReader(new FileReader(&quot;d:七里香.txt&quot;)</span><br><span class="line">try(br)&#123;</span><br><span class="line">  br.readLine();</span><br><span class="line">&#125;catch(IOException e)&#123;</span><br><span class="line">  log.error(&quot;IO 异常，e:&#123;&#125;&quot;,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-Stream-API的改进"><a href="#9-Stream-API的改进" class="headerlink" title="9. Stream API的改进"></a>9. Stream API的改进</h4><p>JDK 9 为Stream API引入以下这些方法，丰富了流处理操作：</p>
<ul>
<li>takeWhile（）</li>
<li>dropWhile（）</li>
<li>iterate</li>
<li>ofNullable</li>
</ul>
<p><strong>takeWhile</strong></p>
<p>使用一个断言（Predicate 接口）作为参数，返回给定Stream的子集直到断言语句第一次返回 false</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 语法格式</span><br><span class="line">default Stream&lt;T&gt; takeWhile(Predicate&lt;? super T&gt; predicate)</span><br><span class="line">//代码示例</span><br><span class="line">Stream.of(1,2,3).takeWhile(s-&gt; x&lt;2)</span><br><span class="line">         .forEach(System.out::println); </span><br><span class="line"> //输出</span><br><span class="line"> 1</span><br></pre></td></tr></table></figure>
<p><strong>dropWhile</strong></p>
<p>与 takeWhile（）作用相反，使用一个断言（Predicate 接口）作为参数，直到断言语句第一次返回true，返回给定Stream的子集</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//语法</span><br><span class="line">default Stream&lt;T&gt; dropWhile(Predicate&lt;? super T&gt; predicate)</span><br><span class="line">//代码示例</span><br><span class="line">Stream.of(1,2,3).dropWhile(s-&gt; x&lt;2)</span><br><span class="line">         .forEach(System.out::println);</span><br><span class="line">//输出</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p><strong>iterate</strong></p>
<p>iterate() 方法能够返回以seed（第一个参数）开头，匹配 Predicate（第二个参数）直到返回false，并使用第三个参数生成下一个元素的元素流。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//语法</span><br><span class="line">static &lt;T&gt; Stream&lt;T&gt; iterate(T seed, Predicate&lt;? super T&gt; hasNext, UnaryOperator&lt;T&gt; next)</span><br><span class="line">//代码示例</span><br><span class="line">IntStream.iterate(2, x -&gt; x &lt; 10, x -&gt; x*x).forEach(System.out::println);</span><br><span class="line">//输出</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p><strong>ofNullable</strong></p>
<p>如果指定元素为非null，则获取一个元素并生成单个元素流，元素为null则返回一个空Stream。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//语法</span><br><span class="line">static &lt;T&gt; Stream&lt;T&gt; ofNullable(T t)</span><br><span class="line">//代码示例</span><br><span class="line">Stream&lt;Integer&gt; s1= Stream.ofNullable(100);</span><br><span class="line">s1.forEach(System.out::println)</span><br><span class="line">Stream&lt;Integer&gt; s2 = Stream.ofNullable(null)；</span><br><span class="line">s2.forEach(System.out::println)</span><br><span class="line">//输出</span><br><span class="line">100</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="10-其他"><a href="#10-其他" class="headerlink" title="10.其他"></a>10.其他</h4><blockquote>
<ul>
<li>HTTP 2客户端 (支持 WebSocket和 HTTP2 流以及服务器推送)</li>
<li>进程API（控制和管理操作系统进程）</li>
<li>String底层存储结构更改(char[]替换为byte[])</li>
<li>标识符添加限制( String _ &#x3D;”hello”不能用)</li>
<li>响应式流 API (支持Java 9中的响应式编程)</li>
</ul>
</blockquote>
<h3 id="Java-10-新特性"><a href="#Java-10-新特性" class="headerlink" title="Java 10 新特性"></a>Java 10 新特性</h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1641de35ea274dbb9d7d34c78ea40a0f~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h4 id="1-局部变量类型推断"><a href="#1-局部变量类型推断" class="headerlink" title="1.局部变量类型推断"></a>1.局部变量类型推断</h4><p>JDK 10增加了局部变量类型推断（Local-Variable Type Inference）功能，让 Java 可以像Js里的var一样可以自动推断数据类型。Java中的var是一个保留类型名称，而不是关键字。</p>
<p>JDK 10之前</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">Stream&lt;Integer&gt; stream = Stream.of(1, 2, 3);</span><br></pre></td></tr></table></figure>
<p>JDK 10 之后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var list = new ArrayList&lt;String&gt;(); // ArrayList&lt;String&gt;</span><br><span class="line">var stream =  Stream.of(1, 2, 3);</span><br></pre></td></tr></table></figure>
<p>var 变量类型推断的使用也有局限性，仅<strong>局限</strong>于以下场景：</p>
<ul>
<li>具有初始化器的局部变量</li>
<li>增强型for循环中的索引变量</li>
<li>传统for循环中声明的局部变量</li>
</ul>
<p>而<strong>不能用于</strong></p>
<ul>
<li>推断方法的参数类型</li>
<li>构造函数参数类型推断</li>
<li>推断方法返回类型</li>
<li>字段类型推断</li>
<li>捕获表达式</li>
</ul>
<h4 id="2-不可变集合的改进"><a href="#2-不可变集合的改进" class="headerlink" title="2. 不可变集合的改进"></a>2. 不可变集合的改进</h4><p>JDK 10中，List，Set，Map 提供了一个新的静态方法copyOf(Collection&lt;? extends E&gt; coll)，它返回Collection集合一个不可修改的副本。</p>
<p>JDK 源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static &lt;E&gt; List&lt;E&gt; copyOf(Collection&lt;? extends E&gt; coll) &#123;</span><br><span class="line">    return ImmutableCollections.listCopy(coll);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var oldList = new ArrayList&lt;String&gt;();</span><br><span class="line">oldList.add(&quot;欢迎关注公众号：&quot;);</span><br><span class="line">oldList.add(&quot;捡田螺的小男孩&quot;);</span><br><span class="line"></span><br><span class="line">var copyList = List.copyOf(oldList);</span><br><span class="line">oldList.add(&quot;在看、转载、点赞三连&quot;); </span><br><span class="line">copyList.add(&quot;双击666&quot;);  //UnsupportedOperationException异常</span><br></pre></td></tr></table></figure>

<h4 id="3-并行全垃圾回收器-G1"><a href="#3-并行全垃圾回收器-G1" class="headerlink" title="3. 并行全垃圾回收器 G1"></a>3. 并行全垃圾回收器 G1</h4><blockquote>
<p>JDK 9引入 G1 作为默认垃圾收集器，执行GC 时采用的是基于单线程标记扫描压缩算法（mark-sweep-compact）。为了最大限度地减少 Full GC 造成的应用停顿的影响，Java 10 中将为 G1 引入多线程并行 GC，同时会使用与年轻代回收和混合回收相同的并行工作线程数量，从而减少了 Full GC 的发生，以带来更好的性能提升、更大的吞吐量。</p>
</blockquote>
<h4 id="4-线程本地握手"><a href="#4-线程本地握手" class="headerlink" title="4. 线程本地握手"></a>4. 线程本地握手</h4><p>Java 10 中线程管控引入JVM安全点的概念，将允许在不运行全局JVM安全点的情况下实现线程回调，由线程本身或者JVM线程来执行，同时保持线程处于阻塞状态，这将会很方便使得停止单个线程或不停止线程成为可能。</p>
<h4 id="5-Optional新增orElseThrow-方法"><a href="#5-Optional新增orElseThrow-方法" class="headerlink" title="5. Optional新增orElseThrow()方法"></a>5. Optional新增orElseThrow()方法</h4><p>Optional、OptionalDouble等类新增一个方法orElseThrow()，在没有值时抛出异常</p>
<h4 id="6-其他新特性"><a href="#6-其他新特性" class="headerlink" title="6. 其他新特性"></a>6. 其他新特性</h4><ul>
<li>基于 Java 的 实验性 JIT 编译器</li>
<li>类数据共享</li>
<li>Unicode 语言标签扩展</li>
<li>根证书</li>
<li>基于时间（Time-Based）的版本控制模型</li>
</ul>
<h3 id="Java-11-新特性"><a href="#Java-11-新特性" class="headerlink" title="Java 11 新特性"></a>Java 11 新特性</h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4041b93cd08c4865aaceec2bafbd214f~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h4 id="1-字符串操作"><a href="#1-字符串操作" class="headerlink" title="1.字符串操作"></a>1.字符串操作</h4><p>String类是Java最常用的类，JDK 11增加了一系列好用的字符串处理方法</p>
<ul>
<li>isBlank() 判空。</li>
<li>strip() 去除首尾空格</li>
<li>stripLeading() 去除字符串首部空格 </li>
<li>stripTrailing() 去除字符串尾部空格</li>
<li>lines() 分割获取字符串流。</li>
<li>repeat() 复制字符串</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 判断字符串是否为空白</span><br><span class="line">&quot;  &quot;.isBlank();    // true</span><br><span class="line"></span><br><span class="line">// 去除首尾空格</span><br><span class="line">&quot; jay &quot;.strip();  // &quot;jay&quot;</span><br><span class="line"></span><br><span class="line">// 去除首部空格 </span><br><span class="line">&quot; jay &quot;.stripLeading();   // &quot;jay &quot;</span><br><span class="line"></span><br><span class="line">去除字符串尾部空格</span><br><span class="line">&quot; jay &quot;.stripLeading();   // &quot; jay&quot;</span><br><span class="line"></span><br><span class="line">// 行数统计</span><br><span class="line">&quot;a\nb\nc&quot;.lines().count();    // 3</span><br><span class="line"></span><br><span class="line">// 复制字符串</span><br><span class="line">&quot;jay&quot;.repeat(3);   // &quot;jayjayjay&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-用于-Lambda-参数的局部变量语法"><a href="#2-用于-Lambda-参数的局部变量语法" class="headerlink" title="2.用于 Lambda 参数的局部变量语法"></a>2.用于 Lambda 参数的局部变量语法</h4><p>局部变量类型推断是Java 10引入的新特性，但是不能在Lambda 表达式中使用。Java 11再次创新，它允许开发者在 Lambda 表达式中使用 var 进行参数声明。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">map.put(&quot;公众号&quot;, &quot;捡田螺的小男孩&quot;);</span><br><span class="line">map.forEach((var k, var v) -&gt; &#123;</span><br><span class="line">    System.out.println(k + &quot;: &quot; + v);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="3-标准化HTTP-Client"><a href="#3-标准化HTTP-Client" class="headerlink" title="3.标准化HTTP Client"></a>3.标准化HTTP Client</h4><p>Java 9 引入Http Client API,Java 10对它更新，Java 11 对它进行标准化。这几个版本后，Http Client几乎被完全重写，支持HTTP&#x2F;1.1和HTTP&#x2F;2 ，也支持 websockets。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HttpClient client = HttpClient.newHttpClient();</span><br><span class="line">HttpRequest request = HttpRequest.newBuilder()</span><br><span class="line">            .uri(URI.create(&quot;https://github.com/whx123/JavaHome&quot;))</span><br><span class="line">            .GET()</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">// 同步</span><br><span class="line">HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">System.out.println(response.body());</span><br><span class="line"></span><br><span class="line">// 异步</span><br><span class="line">client.sendAsync(request, HttpResponse.BodyHandlers.ofString())</span><br><span class="line">    .thenApply(HttpResponse::body)</span><br><span class="line">    .thenAccept(System.out::println);</span><br></pre></td></tr></table></figure>

<h4 id="4-单个命令编译运行源代码"><a href="#4-单个命令编译运行源代码" class="headerlink" title="4. 单个命令编译运行源代码"></a>4. 单个命令编译运行源代码</h4><p>Java 11增强了Java 启动器，使之能够运行单一文件的Java 源代码。</p>
<ul>
<li>Java 11之前,要运行一个 Java 源代码必须先编译，再运行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 编译</span><br><span class="line">javac Jay.java</span><br><span class="line">// 运行</span><br><span class="line">java Jay</span><br></pre></td></tr></table></figure></li>
<li>Java 11之后,只要一个java命令就搞定<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java Jay.java</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="5-ZGC：可伸缩低延迟垃圾收集器"><a href="#5-ZGC：可伸缩低延迟垃圾收集器" class="headerlink" title="5. ZGC：可伸缩低延迟垃圾收集器"></a>5. ZGC：可伸缩低延迟垃圾收集器</h4><p>ZGC ，即 Z Garbage Collector（垃圾收集器或垃圾回收器）。它是一个可伸缩的、低延迟的垃圾收集器。<br>ZGC 主要为了满足如下目标进行设计：</p>
<ul>
<li>GC 停顿时间不超过 10ms</li>
<li>既能处理几百 MB 的小堆，也能处理几个 TB 的大堆</li>
<li>应用吞吐能力不会下降超过 15%（与 G1 回收算法相比）</li>
<li>方便在此基础上引入新的 GC 特性和利用 colord</li>
<li>针以及 Load barriers 优化奠定基础</li>
<li>当前只支持 Linux&#x2F;x64 位平台</li>
</ul>
<h4 id="6-其他一些特性"><a href="#6-其他一些特性" class="headerlink" title="6.其他一些特性"></a>6.其他一些特性</h4><ul>
<li>添加 Epsilon 垃圾收集器。</li>
<li>支持 TLS 1.3 协议</li>
<li>飞行记录器分析工具</li>
<li>动态类文件常量</li>
<li>低开销的 Heap Profiling</li>
</ul>
<h3 id="Java-12-新特性"><a href="#Java-12-新特性" class="headerlink" title="Java 12 新特性"></a>Java 12 新特性</h3><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9700faac24f45508d6f7071e779d1b8~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h4 id="1-Switch-表达式扩展（预览功能）"><a href="#1-Switch-表达式扩展（预览功能）" class="headerlink" title="1. Switch 表达式扩展（预览功能）"></a>1. Switch 表达式扩展（预览功能）</h4><p>传统的switch语句，容易漏写break而出错，同时写法并不简洁优雅。</p>
<p>Java 12之前</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">switch (day) &#123;</span><br><span class="line">    case MONDAY:</span><br><span class="line">    case FRIDAY:</span><br><span class="line">    case SUNDAY:</span><br><span class="line">        System.out.println(6);</span><br><span class="line">        break;</span><br><span class="line">    case TUESDAY:</span><br><span class="line">        System.out.println(7);</span><br><span class="line">        break;</span><br><span class="line">    case THURSDAY:</span><br><span class="line">    case SATURDAY:</span><br><span class="line">        System.out.println(8);</span><br><span class="line">        break;</span><br><span class="line">    case WEDNESDAY:</span><br><span class="line">        System.out.println(9);</span><br><span class="line">        break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>JDk 12 之后，Switch表达式得到增强，能接受语句和表达式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">switch (day) &#123;</span><br><span class="line">    case MONDAY, FRIDAY, SUNDAY -&gt; System.out.println(6);</span><br><span class="line">    case TUESDAY                -&gt; System.out.println(7);</span><br><span class="line">    case THURSDAY, SATURDAY     -&gt; System.out.println(8);</span><br><span class="line">    case WEDNESDAY              -&gt; System.out.println(9);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-紧凑的数据格式"><a href="#2-紧凑的数据格式" class="headerlink" title="2. 紧凑的数据格式"></a>2. 紧凑的数据格式</h4><p>JDK 12 新增了NumberFormat对复杂数字的格式化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NumberFormat numberFormat = NumberFormat.getCompactNumberInstance(Locale.CHINA, NumberFormat.Style.SHORT);</span><br><span class="line">System.out.println(numberFormat.format(100000));</span><br><span class="line">//output</span><br><span class="line">10万</span><br></pre></td></tr></table></figure>

<h4 id="3-字符串支持transform、indent操作"><a href="#3-字符串支持transform、indent操作" class="headerlink" title="3. 字符串支持transform、indent操作"></a>3. 字符串支持transform、indent操作</h4><ul>
<li>transform 字符串转换，可以配合函数式接口Function一起使用<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list1 = List.of(&quot;jay&quot;, &quot; 捡田螺的小男孩&quot;);</span><br><span class="line">List&lt;String&gt; list2 = new ArrayList&lt;&gt;();</span><br><span class="line">list1.forEach(element -&gt;</span><br><span class="line">            list2.add(element.transform(String::strip)</span><br><span class="line">                    .transform((e) -&gt; &quot;Hello,&quot; + e))</span><br><span class="line">    );</span><br><span class="line">list2.forEach(System.out::println);</span><br><span class="line">//输出</span><br><span class="line">Hello,jay</span><br><span class="line">Hello,捡田螺的小男孩</span><br></pre></td></tr></table></figure></li>
<li>indent 缩进，每行开头增加空格space和移除空格<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String result = &quot;Java\n Python\nC&quot;.indent(3);</span><br><span class="line">System.out.println(result);</span><br><span class="line">//输出</span><br><span class="line">   Java</span><br><span class="line">    Python</span><br><span class="line">   C</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-Files-mismatch-Path-Path"><a href="#4-Files-mismatch-Path-Path" class="headerlink" title="4. Files.mismatch(Path, Path)"></a>4. Files.mismatch(Path, Path)</h4><p>Java 12 新增了mismatch方法，此方法返回第一个不匹配的位置，如果没有不匹配，则返回 -1L。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static long mismatch(Path path, Path path2) throws IOException;</span><br></pre></td></tr></table></figure>
<p>代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Path file1 = Paths.get(&quot;c:\\jay.txt&quot;);</span><br><span class="line">Path file2 = Paths.get(&quot;c：\\捡田螺的小男孩.txt&quot;);</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"> long fileMismatch = Files.mismatch(file1, file2);</span><br><span class="line"> System.out.println(fileMismatch);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-Teeing-Collector"><a href="#5-Teeing-Collector" class="headerlink" title="5. Teeing Collector"></a>5. Teeing Collector</h4><p>Teeing Collector 是 Streams API 中引入的新的收集器实用程序，它的作用是 merge 两个 collector 的结果,API格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T, R1, R2, R&gt;</span><br><span class="line">    Collector&lt;T, ?, R&gt; teeing(Collector&lt;? super T, ?, R1&gt; downstream1,</span><br><span class="line">    Collector&lt;? super T, ?, R2&gt; downstream2,</span><br><span class="line">    BiFunction&lt;? super R1, ? super R2, R&gt; merger)</span><br></pre></td></tr></table></figure>
<p>直接看代码例子吧，如下为求学生的平均分和总分的例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> List&lt;Student&gt; studentList= Arrays.asList(</span><br><span class="line">               new Student(&quot;jay&quot;, 90),</span><br><span class="line">               new Student(&quot;捡田螺的小男孩&quot;, 100),</span><br><span class="line">               new Student(&quot;捡表情的小男孩&quot;, 80)</span><br><span class="line">       );</span><br><span class="line">       String teeingResult=studentList.stream().collect(</span><br><span class="line">               Collectors.teeing(</span><br><span class="line">                       Collectors.averagingInt(Student::getScore),</span><br><span class="line">                       Collectors.summingInt(Student::getScore),</span><br><span class="line">                       (s1,s2)-&gt; s1+ &quot;:&quot;+ s2</span><br><span class="line">               )</span><br><span class="line">       );</span><br><span class="line">System.out.println(teeingResult); //90:270</span><br></pre></td></tr></table></figure>
<h4 id="6-其他特性"><a href="#6-其他特性" class="headerlink" title="6.其他特性"></a>6.其他特性</h4><ul>
<li>支持unicode 11（684个新字符、11个新blocks、7个新脚本）</li>
<li>JVM 常量 API （主要在新的java.lang.invoke.constant包中定义了一系列基于值的符号引用类型，能够描述每种可加载常量。）</li>
<li>Shenandoah GC（低暂停时间垃圾收集器）</li>
<li>G1 收集器提升 （可中止的混合收集集合、及时返回未使用的已分配内存）</li>
<li>默认CDS档案</li>
<li>JMH 基准测试</li>
</ul>
<h3 id="Java-13-新特性"><a href="#Java-13-新特性" class="headerlink" title="Java 13 新特性"></a>Java 13 新特性</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/404668ad77d248ec97d482622182eb70~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h4 id="Switch-表达式扩展（引入-yield-关键字）"><a href="#Switch-表达式扩展（引入-yield-关键字）" class="headerlink" title="Switch 表达式扩展（引入 yield 关键字）"></a>Switch 表达式扩展（引入 yield 关键字）</h4><p>传统的switch：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private static String getText(int number) &#123;</span><br><span class="line">    String result = &quot;&quot;;</span><br><span class="line">    switch (number) &#123;</span><br><span class="line">        case 1, 2:</span><br><span class="line">        result = &quot;one or two&quot;;</span><br><span class="line">        break;</span><br><span class="line">        case 3:</span><br><span class="line">        result = &quot;three&quot;;</span><br><span class="line">        break;</span><br><span class="line">        case 4, 5, 6:</span><br><span class="line">        result = &quot;four or five or six&quot;;</span><br><span class="line">        break;</span><br><span class="line">        default:</span><br><span class="line">        result = &quot;unknown&quot;;</span><br><span class="line">        break;</span><br></pre></td></tr></table></figure>
<p>Java 13之后，value break 语句不再被编译，而是用 yield 来进行值返回</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private static String getText(int number) &#123;</span><br><span class="line">    return switch (number) &#123;</span><br><span class="line">        case 1, 2:</span><br><span class="line">            yield &quot;one or two&quot;;</span><br><span class="line">        case 3:</span><br><span class="line">            yield &quot;three&quot;;</span><br><span class="line">        case 4, 5, 6:</span><br><span class="line">            yield &quot;four or five or six&quot;;</span><br><span class="line">        default:</span><br><span class="line">            yield &quot;unknown&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-文本块升级"><a href="#2-文本块升级" class="headerlink" title="2.文本块升级"></a>2.文本块升级</h4><p>Java 13之前，字符串不能够多行使用，需要通过换行转义或者换行连接符等等，反正就是好麻烦、好难维护。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String html = &quot;&lt;html&gt;\n&quot; +</span><br><span class="line">              &quot;    &lt;body&gt;\n&quot; +</span><br><span class="line">              &quot;        &lt;p&gt;Hello, 捡田螺的小男孩&lt;/p&gt;\n&quot; +</span><br><span class="line">              &quot;    &lt;/body&gt;\n&quot; +</span><br><span class="line">              &quot;&lt;/html&gt;\n&quot;;</span><br></pre></td></tr></table></figure>
<p>Java 13之后，清爽多了~</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String html = &quot;&quot;&quot;</span><br><span class="line">                &lt;html&gt;</span><br><span class="line">                    &lt;body&gt;</span><br><span class="line">                        &lt;p&gt;Hello,  捡田螺的小男孩&lt;/p&gt;</span><br><span class="line">                    &lt;/body&gt;</span><br><span class="line">                &lt;/html&gt;</span><br><span class="line">                &quot;&quot;&quot;;</span><br></pre></td></tr></table></figure>
<h4 id="3-SocketAPI-重构"><a href="#3-SocketAPI-重构" class="headerlink" title="3. SocketAPI 重构"></a>3. SocketAPI 重构</h4><ul>
<li>传统的Java Socket API（java.net.ServerSocket 和 java.net.Socket）依赖于SocketImpl 的内部实现</li>
<li>在 Java 13之前，通过使用 PlainSocketImpl 作为 SocketImpl 的具体实现。</li>
<li>Java 13 中的新底层实现，引入 NioSocketImpl 的实现用以替换 SocketImpl 的 PlainSocketImpl 实现，此实现与 NIO（新 I&#x2F;O）实现共享相同的内部基础结构，并且与现有的缓冲区高速缓存机制集成在一起。</li>
</ul>
<p>一个Socket简单例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line"></span><br><span class="line">public class SocketAPITest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try (ServerSocket serverSocket = new ServerSocket(8080))&#123;</span><br><span class="line">            boolean runFlag = true;</span><br><span class="line">            while(runFlag)&#123;</span><br><span class="line">                Socket clientSocket = serverSocket.accept();</span><br><span class="line">                //搞事情</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行以上的实例，看下是否有以下关键词输出~</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[class,load] sun.nio.ch.NioSocketImpl</span><br></pre></td></tr></table></figure>

<h4 id="4-FileSystems-newFileSystem新方法"><a href="#4-FileSystems-newFileSystem新方法" class="headerlink" title="4.FileSystems.newFileSystem新方法"></a>4.FileSystems.newFileSystem新方法</h4><p>FileSystems 类中添加了以下三种新方法，以便更容易地使用将文件内容视为文件系统的文件系统提供程序：</p>
<ul>
<li>1、newFileSystem(Path)</li>
<li>2、newFileSystem(Path, Map&lt;String, ?&gt;)</li>
<li>3、newFileSystem(Path, Map&lt;String, ?&gt;, ClassLoader)</li>
</ul>
<h4 id="5-增强-ZGC-释放未使用内存"><a href="#5-增强-ZGC-释放未使用内存" class="headerlink" title="5. 增强 ZGC 释放未使用内存"></a>5. 增强 ZGC 释放未使用内存</h4><ul>
<li>ZGC 是Java 11 中引入的最为瞩目的垃圾回收特性，是一种可伸缩、低延迟的垃圾收集器。但是实际使用中，它不能够主动将未使用的内存释放给操作系统。</li>
<li>Java 13 中对 ZGC 的改进，包括释放未使用内存给操作系统、支持最大堆大小为 16TB、JVM参数-XX:SoftMaxHeapSize 来软限制堆大小</li>
</ul>
<h4 id="6-其他特性-1"><a href="#6-其他特性-1" class="headerlink" title="6.其他特性"></a>6.其他特性</h4><ul>
<li>动态 CDS 存档， 扩展了 Java 10 中引入的类数据共享功能， 使用CDS 存档变得更容易。</li>
<li>文本块的字符串类新方法，如formatted(Object…args)，stripIndent()等。</li>
</ul>
<h3 id="Java-14-新特性"><a href="#Java-14-新特性" class="headerlink" title="Java 14 新特性"></a>Java 14 新特性</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c386249741174a38b6d29f6900829a66~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h4 id="1-instanceof模式匹配"><a href="#1-instanceof模式匹配" class="headerlink" title="1. instanceof模式匹配"></a>1. instanceof模式匹配</h4><p>instanceof 传统使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (person instanceof Singer) &#123;</span><br><span class="line">    Singer singer = (Singer) person;</span><br><span class="line">    singer.sing();</span><br><span class="line">&#125; else if (person instanceof Writer) &#123;</span><br><span class="line">    Writer writer = (Writer) person;</span><br><span class="line">    writer.write();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java 14 对 instanceof 进行模式匹配改进之后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (person instanceof Singer singer) &#123;</span><br><span class="line">    singer.sing();</span><br><span class="line">&#125; else if (person instanceof Writer writer) &#123;</span><br><span class="line">   writer.write();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-Record-类型（预览功能）"><a href="#2-Record-类型（预览功能）" class="headerlink" title="2.Record 类型（预览功能）"></a>2.Record 类型（预览功能）</h4><p>Java 14将Record 类型作为预览特性而引入，有点类似于Lombok 的@Data注解，看个例子吧：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public record Person(String name, int age) &#123;</span><br><span class="line">    public static String address;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反编译结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public final class Person extends java.lang.Record &#123;</span><br><span class="line">    private final java.lang.String name;</span><br><span class="line">    private final java.lang.String age;</span><br><span class="line"></span><br><span class="line">    public Person(java.lang.String name, java.lang.String age) &#123; /* compiled code */ &#125;</span><br><span class="line"></span><br><span class="line">    public java.lang.String getName() &#123; /* compiled code */ &#125;</span><br><span class="line"></span><br><span class="line">    public java.lang.String toString() &#123; /* compiled code */ &#125;</span><br><span class="line"></span><br><span class="line">    public final int hashCode() &#123; /* compiled code */ &#125;</span><br><span class="line"></span><br><span class="line">    public final boolean equals(java.lang.Object o) &#123; /* compiled code */ &#125;</span><br><span class="line"></span><br><span class="line">    public java.lang.String name() &#123; /* compiled code */ &#125;</span><br><span class="line"></span><br><span class="line">    public java.lang.String age() &#123; /* compiled code */ &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，当用 Record 来声明一个类时，该类将自动拥有下面特征：</p>
<ul>
<li>构造方法</li>
<li>hashCode() 方法</li>
<li>euqals() 方法</li>
<li>toString() 方法</li>
<li>类对象被final 关键字修饰，不能被继承。</li>
</ul>
<h4 id="3-Switch-表达式-标准化"><a href="#3-Switch-表达式-标准化" class="headerlink" title="3. Switch 表达式-标准化"></a>3. Switch 表达式-标准化</h4><p>switch 表达式在之前的 Java 12 和 Java 13 中都是处于预览阶段，终于在 Java 14 标准化，成为稳定版本。</p>
<ul>
<li>Java 12 为switch 表达式引入Lambda 语法</li>
<li>Java 13 使用yield代替 break 关键字来返回表达式的返回值。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String result = switch (day) &#123;</span><br><span class="line">    case &quot;M&quot;, &quot;W&quot;, &quot;F&quot; -&gt; &quot;MWF&quot;;</span><br><span class="line">    case &quot;T&quot;, &quot;TH&quot;, &quot;S&quot; -&gt; &quot;TTS&quot;;</span><br><span class="line">    default -&gt; &#123;</span><br><span class="line">        if (day.isEmpty()) &#123;</span><br><span class="line">            yield &quot;Please insert a valid day.&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            yield &quot;Looks like a Sunday.&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-改进-NullPointerExceptions提示信息"><a href="#4-改进-NullPointerExceptions提示信息" class="headerlink" title="4. 改进 NullPointerExceptions提示信息"></a>4. 改进 NullPointerExceptions提示信息</h4><p>Java 14 之前：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String name = song.getSinger().getSingerName()</span><br><span class="line"> </span><br><span class="line">//堆栈信息</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException</span><br><span class="line">    at NullPointerExample.main(NullPointerTest.java:6)</span><br></pre></td></tr></table></figure>
<p>Java 14，通过引入JVM 参数-XX:+ShowCodeDetailsInExceptionMessages，可以在空指针异常中获取更为详细的调用信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException: Cannot invoke &quot;Singer.getSingerName()&quot; </span><br><span class="line">because the return value of &quot;rainRow.getSinger()&quot; is null</span><br><span class="line">    at NullPointerExample.main(NullPointerTest.java:6)</span><br></pre></td></tr></table></figure>
<h4 id="5-其他特性"><a href="#5-其他特性" class="headerlink" title="5. 其他特性"></a>5. 其他特性</h4><ul>
<li>G1 的 NUMA 可识别内存分配</li>
<li>删除 CMS 垃圾回收器</li>
<li>GC 支持 MacOS 和 Windows 系统</li>
</ul>
<h3 id="Java-15-新特性"><a href="#Java-15-新特性" class="headerlink" title="Java 15 新特性"></a>Java 15 新特性</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/691c5bdd4de64d41bc5f50599b9ba078~tplv-k3u1fbpfcp-zoom-1.image"><br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96a3928212f1483ca669f6cbc7893c21~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h4 id="1-EdDSA-数字签名算法"><a href="#1-EdDSA-数字签名算法" class="headerlink" title="1.EdDSA 数字签名算法"></a>1.EdDSA 数字签名算法</h4><ul>
<li>使用 Edwards-Curve 数字签名算法（EdDSA）实现加密签名。</li>
<li>与其它签名方案相比，EdDSA 具有更高的安全性和性能。</li>
<li>得到许多其它加密库（如 OpenSSL、BoringSSL）的支持。</li>
</ul>
<h4 id="2-Sealed-Classes（封闭类，预览）"><a href="#2-Sealed-Classes（封闭类，预览）" class="headerlink" title="2.Sealed Classes（封闭类，预览）"></a>2.Sealed Classes（封闭类，预览）</h4><p>封闭类，可以是封闭类、封闭接口，防止其他类或接口扩展或实现它们。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public abstract sealed class Singer</span><br><span class="line">    permits Jay, Eason&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类Singer被sealed 修饰，是封闭类，只能被2个指定子类（Jay, Eason）继承。</p>
<h4 id="3-Hidden-Classes（隐藏类）"><a href="#3-Hidden-Classes（隐藏类）" class="headerlink" title="3. Hidden Classes（隐藏类）"></a>3. Hidden Classes（隐藏类）</h4><ul>
<li>隐藏类天生为框架设计的。</li>
<li>隐藏类只能通过反射访问，不能直接被其他类的字节码。</li>
</ul>
<h4 id="4-Remove-the-Nashorn-JavaScript-Engine"><a href="#4-Remove-the-Nashorn-JavaScript-Engine" class="headerlink" title="4. Remove the Nashorn JavaScript Engine"></a>4. Remove the Nashorn JavaScript Engine</h4><ul>
<li>Nashorn太难维护了，移除 Nashorn JavaScript引擎成为一种必然</li>
<li>其实早在JDK 11 中就已经被标记为 deprecated 了。</li>
</ul>
<h4 id="5-Reimplement-the-Legacy-DatagramSocket-API（重新实现DatagramSocket-API）"><a href="#5-Reimplement-the-Legacy-DatagramSocket-API（重新实现DatagramSocket-API）" class="headerlink" title="5.Reimplement the Legacy DatagramSocket API（重新实现DatagramSocket API）"></a>5.Reimplement the Legacy DatagramSocket API（重新实现DatagramSocket API）</h4><ul>
<li>重新实现老的DatagramSocket API</li>
<li>更改java.net.DatagramSocket 和 java.net.MulticastSocket 为更加简单、现代化的底层实现。</li>
</ul>
<h4 id="6-其他"><a href="#6-其他" class="headerlink" title="6.其他"></a>6.其他</h4><ul>
<li>Disable and Deprecate Biased Locking（准备禁用偏向锁）</li>
<li>instanceof 自动匹配模式（预览）</li>
<li>ZGC，一个可伸缩、低延迟的垃圾回收器。（转正）</li>
<li>Text Blocks，文本功能转正（JDK 13和14预览，14终于转正）</li>
<li>Remove the Solaris and SPARC Ports（删除 Solaris 和 SPARC 端口）</li>
<li>外部存储器访问 API（允许Java 应用程序安全有效地访问 Java 堆之外的外部内存。）</li>
<li>Record类型二次预览（在Java 14就预览过啦）</li>
</ul>
<h3 id="参考与感谢"><a href="#参考与感谢" class="headerlink" title="参考与感谢"></a>参考与感谢</h3><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40926603/article/details/84970283">JDK6 新特性</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/213958/new-features-in-java-7">Java 7的新功能</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.ibm.com/zh/articles/the-new-features-of-Java-9/">Java 9 新特性概述</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java9-new-features.html">Java 9 新特性</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.ibm.com/zh/technologies/java/articles/the-new-features-of-java-10/">Java 10 新特性介绍</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.ibm.com/zh/technologies/java/articles/the-new-features-of-java-11/">Java 11 新特性介绍</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.ibm.com/zh/technologies/java/articles/the-new-features-of-java-13/">Java 13 新特性概述</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.ibm.com/zh/technologies/java/articles/the-new-features-of-java-14/">Java 14 新特性概述</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/bNbNzo-Jy_SskRAupUBbNQ">JDK&#x2F;Java 15发布</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/javastack/p/13683220.html">Java 15 正式发布， 14 个新特性，刷新你的认知！！
</a></li>
</ul>
<h3 id="个人公众号"><a href="#个人公众号" class="headerlink" title="个人公众号"></a>个人公众号</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2845e9f737f14311a119f45751683b3c~tplv-k3u1fbpfcp-zoom-1.image"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">woaker</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/06/19/JavaHome/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80%EF%BC%9AJDK%205-15%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BB%8F%E5%85%B8%E6%96%B0%E7%89%B9%E6%80%A7/">http://example.com/2022/06/19/JavaHome/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80%EF%BC%9AJDK%205-15%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BB%8F%E5%85%B8%E6%96%B0%E7%89%B9%E6%80%A7/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">每天都不一样</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/image/4.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/06/19/JavaHome/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/Java%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E5%8D%81%E4%B8%AA%E5%BB%BA%E8%AE%AE/"><img class="prev-cover" src="/image/3.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java异常处理的十个建议</div></div></a></div><div class="next-post pull-right"><a href="/2022/06/19/my-first-blog/"><img class="next-cover" src="/image/15.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">my-first-blog</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">woaker</div><div class="author-info__description">不积跬步无以至千里</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">135</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/woaker"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-5-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">2.</span> <span class="toc-text">Java 5 新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%B3%9B%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">1. 泛型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A2%9E%E5%BC%BA%E5%BE%AA%E7%8E%AF%EF%BC%88for-each%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">2. 增强循环（for-each）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%87%AA%E5%8A%A8%E5%B0%81%E7%AE%B1%E6%8B%86%E7%AE%B1"><span class="toc-number">2.3.</span> <span class="toc-text">3. 自动封箱拆箱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%9E%9A%E4%B8%BE"><span class="toc-number">2.4.</span> <span class="toc-text">4. 枚举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">2.5.</span> <span class="toc-text">5. 可变参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.6.</span> <span class="toc-text">6. 注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E9%9D%99%E6%80%81%E5%AF%BC%E5%85%A5"><span class="toc-number">2.7.</span> <span class="toc-text">7.静态导入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%BA%93%EF%BC%88JUC%EF%BC%89"><span class="toc-number">2.8.</span> <span class="toc-text">8. 线程并发库（JUC）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-6-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">3.</span> <span class="toc-text">Java 6 新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Desktop%E7%B1%BB%E5%92%8CSystemTray%E7%B1%BB"><span class="toc-number">3.1.</span> <span class="toc-text">1.Desktop类和SystemTray类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8JAXB2%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E4%B8%8EXML%E4%B9%8B%E9%97%B4%E7%9A%84%E6%98%A0%E5%B0%84"><span class="toc-number">3.2.</span> <span class="toc-text">2. 使用JAXB2来实现对象与XML之间的映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%BD%BB%E9%87%8F%E7%BA%A7-Http-Server-API"><span class="toc-number">3.3.</span> <span class="toc-text">3.轻量级 Http Server API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%8F%92%E5%85%A5%E5%BC%8F%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86API"><span class="toc-number">3.4.</span> <span class="toc-text">4. 插入式注解处理API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-STAX"><span class="toc-number">3.5.</span> <span class="toc-text">5. STAX</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Common-Annotations"><span class="toc-number">3.6.</span> <span class="toc-text">6. Common Annotations</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-Compiler-API"><span class="toc-number">3.7.</span> <span class="toc-text">7. Compiler API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E5%AF%B9%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E7%9A%84%E6%94%AF%E6%8C%81%EF%BC%88%E5%A6%82-ruby-groovy-javascript%EF%BC%89"><span class="toc-number">3.8.</span> <span class="toc-text">8. 对脚本语言的支持（如: ruby, groovy, javascript）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-7-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">4.</span> <span class="toc-text">Java 7 新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-switch-%E6%94%AF%E6%8C%81String%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E3%80%82"><span class="toc-number">4.1.</span> <span class="toc-text">1.switch 支持String字符串类型。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-try-with-resources%EF%BC%8C%E8%B5%84%E6%BA%90%E8%87%AA%E5%8A%A8%E5%85%B3%E9%97%AD"><span class="toc-number">4.2.</span> <span class="toc-text">2.try-with-resources，资源自动关闭</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%A6%82%EF%BC%88byte%EF%BC%8Cshort%EF%BC%8Cint%EF%BC%8Clong%EF%BC%89%E8%83%BD%E5%A4%9F%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9D%A5%E8%A1%A8%E7%A4%BA"><span class="toc-number">4.3.</span> <span class="toc-text">3. 整数类型如（byte，short，int，long）能够用二进制来表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%95%B0%E5%AD%97%E5%B8%B8%E9%87%8F%E6%94%AF%E6%8C%81%E4%B8%8B%E5%88%92%E7%BA%BF"><span class="toc-number">4.4.</span> <span class="toc-text">4. 数字常量支持下划线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%B3%9B%E5%9E%8B%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%B1%BB%E5%9E%8B%E8%87%AA%E5%8A%A8%E6%8E%A8%E6%96%AD-%E5%8D%B3%E2%80%9D-lt-gt-%E2%80%9D"><span class="toc-number">4.5.</span> <span class="toc-text">5. 泛型实例化类型自动推断,即”&lt;&gt;”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E4%B8%80%E4%B8%AAcatch%E4%B8%AD%E6%8D%95%E8%8E%B7%E5%A4%9A%E4%B8%AA%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B%EF%BC%8C%E7%94%A8%EF%BC%88-%EF%BC%89%E5%88%86%E9%9A%94%E5%BC%80"><span class="toc-number">4.6.</span> <span class="toc-text">6.一个catch中捕获多个异常类型，用（|）分隔开</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%A2%9E%E5%BC%BA%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.7.</span> <span class="toc-text">7. 增强的文件系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-Fork-x2F-join-%E6%A1%86%E6%9E%B6"><span class="toc-number">4.8.</span> <span class="toc-text">8. Fork&#x2F;join 框架</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-8-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">5.</span> <span class="toc-text">Java 8 新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-lambada%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">5.1.</span> <span class="toc-text">1.lambada表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.2.</span> <span class="toc-text">2. 函数式接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-number">5.3.</span> <span class="toc-text">3. 方法引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="toc-number">5.4.</span> <span class="toc-text">4. 默认方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Stream-API"><span class="toc-number">5.5.</span> <span class="toc-text">5.Stream API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Optional"><span class="toc-number">5.6.</span> <span class="toc-text">6. Optional</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-Date-Time-API"><span class="toc-number">5.7.</span> <span class="toc-text">7. Date Time API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E9%87%8D%E5%A4%8D%E6%B3%A8%E8%A7%A3"><span class="toc-number">5.8.</span> <span class="toc-text">8. 重复注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-Base64"><span class="toc-number">5.9.</span> <span class="toc-text">9. Base64</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-JVM%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">5.10.</span> <span class="toc-text">10. JVM的新特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-9-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">6.</span> <span class="toc-text">Java 9 新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-java%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F"><span class="toc-number">6.1.</span> <span class="toc-text">1. java模块系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%9B%86%E5%90%88%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="toc-number">6.2.</span> <span class="toc-text">2. 不可变集合工厂方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%8E%A5%E5%8F%A3%E6%94%AF%E6%8C%81%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-number">6.3.</span> <span class="toc-text">3. 接口支持私有方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%92%BB%E7%9F%B3%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%8D%87%E7%BA%A7"><span class="toc-number">6.4.</span> <span class="toc-text">4.  钻石操作符升级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Optional-%E7%B1%BB%E6%94%B9%E8%BF%9B"><span class="toc-number">6.5.</span> <span class="toc-text">5. Optional 类改进</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%85%BC%E5%AE%B9Jar%E5%8C%85"><span class="toc-number">6.6.</span> <span class="toc-text">6. 多版本兼容Jar包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-JShell%E5%B7%A5%E5%85%B7"><span class="toc-number">6.7.</span> <span class="toc-text">7. JShell工具</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-try-with-resources%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-number">6.8.</span> <span class="toc-text">8. try-with-resources的改进</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-Stream-API%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-number">6.9.</span> <span class="toc-text">9. Stream API的改进</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E5%85%B6%E4%BB%96"><span class="toc-number">6.10.</span> <span class="toc-text">10.其他</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-10-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">7.</span> <span class="toc-text">Java 10 新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-number">7.1.</span> <span class="toc-text">1.局部变量类型推断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%9B%86%E5%90%88%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-number">7.2.</span> <span class="toc-text">2. 不可变集合的改进</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B9%B6%E8%A1%8C%E5%85%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8-G1"><span class="toc-number">7.3.</span> <span class="toc-text">3. 并行全垃圾回收器 G1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E6%8F%A1%E6%89%8B"><span class="toc-number">7.4.</span> <span class="toc-text">4. 线程本地握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Optional%E6%96%B0%E5%A2%9EorElseThrow-%E6%96%B9%E6%B3%95"><span class="toc-number">7.5.</span> <span class="toc-text">5. Optional新增orElseThrow()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%85%B6%E4%BB%96%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">7.6.</span> <span class="toc-text">6. 其他新特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-11-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">8.</span> <span class="toc-text">Java 11 新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C"><span class="toc-number">8.1.</span> <span class="toc-text">1.字符串操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%94%A8%E4%BA%8E-Lambda-%E5%8F%82%E6%95%B0%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%AF%AD%E6%B3%95"><span class="toc-number">8.2.</span> <span class="toc-text">2.用于 Lambda 参数的局部变量语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%A0%87%E5%87%86%E5%8C%96HTTP-Client"><span class="toc-number">8.3.</span> <span class="toc-text">3.标准化HTTP Client</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%8D%95%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="toc-number">8.4.</span> <span class="toc-text">4. 单个命令编译运行源代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-ZGC%EF%BC%9A%E5%8F%AF%E4%BC%B8%E7%BC%A9%E4%BD%8E%E5%BB%B6%E8%BF%9F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">8.5.</span> <span class="toc-text">5. ZGC：可伸缩低延迟垃圾收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%85%B6%E4%BB%96%E4%B8%80%E4%BA%9B%E7%89%B9%E6%80%A7"><span class="toc-number">8.6.</span> <span class="toc-text">6.其他一些特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-12-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">9.</span> <span class="toc-text">Java 12 新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Switch-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%89%A9%E5%B1%95%EF%BC%88%E9%A2%84%E8%A7%88%E5%8A%9F%E8%83%BD%EF%BC%89"><span class="toc-number">9.1.</span> <span class="toc-text">1. Switch 表达式扩展（预览功能）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%B4%A7%E5%87%91%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="toc-number">9.2.</span> <span class="toc-text">2. 紧凑的数据格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%94%AF%E6%8C%81transform%E3%80%81indent%E6%93%8D%E4%BD%9C"><span class="toc-number">9.3.</span> <span class="toc-text">3. 字符串支持transform、indent操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Files-mismatch-Path-Path"><span class="toc-number">9.4.</span> <span class="toc-text">4. Files.mismatch(Path, Path)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Teeing-Collector"><span class="toc-number">9.5.</span> <span class="toc-text">5. Teeing Collector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7"><span class="toc-number">9.6.</span> <span class="toc-text">6.其他特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-13-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">10.</span> <span class="toc-text">Java 13 新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Switch-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%89%A9%E5%B1%95%EF%BC%88%E5%BC%95%E5%85%A5-yield-%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89"><span class="toc-number">10.1.</span> <span class="toc-text">Switch 表达式扩展（引入 yield 关键字）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%96%87%E6%9C%AC%E5%9D%97%E5%8D%87%E7%BA%A7"><span class="toc-number">10.2.</span> <span class="toc-text">2.文本块升级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-SocketAPI-%E9%87%8D%E6%9E%84"><span class="toc-number">10.3.</span> <span class="toc-text">3. SocketAPI 重构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-FileSystems-newFileSystem%E6%96%B0%E6%96%B9%E6%B3%95"><span class="toc-number">10.4.</span> <span class="toc-text">4.FileSystems.newFileSystem新方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%A2%9E%E5%BC%BA-ZGC-%E9%87%8A%E6%94%BE%E6%9C%AA%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98"><span class="toc-number">10.5.</span> <span class="toc-text">5. 增强 ZGC 释放未使用内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7-1"><span class="toc-number">10.6.</span> <span class="toc-text">6.其他特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-14-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">11.</span> <span class="toc-text">Java 14 新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-instanceof%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">11.1.</span> <span class="toc-text">1. instanceof模式匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Record-%E7%B1%BB%E5%9E%8B%EF%BC%88%E9%A2%84%E8%A7%88%E5%8A%9F%E8%83%BD%EF%BC%89"><span class="toc-number">11.2.</span> <span class="toc-text">2.Record 类型（预览功能）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Switch-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E6%A0%87%E5%87%86%E5%8C%96"><span class="toc-number">11.3.</span> <span class="toc-text">3. Switch 表达式-标准化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%94%B9%E8%BF%9B-NullPointerExceptions%E6%8F%90%E7%A4%BA%E4%BF%A1%E6%81%AF"><span class="toc-number">11.4.</span> <span class="toc-text">4. 改进 NullPointerExceptions提示信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7"><span class="toc-number">11.5.</span> <span class="toc-text">5. 其他特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-15-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">12.</span> <span class="toc-text">Java 15 新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-EdDSA-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95"><span class="toc-number">12.1.</span> <span class="toc-text">1.EdDSA 数字签名算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Sealed-Classes%EF%BC%88%E5%B0%81%E9%97%AD%E7%B1%BB%EF%BC%8C%E9%A2%84%E8%A7%88%EF%BC%89"><span class="toc-number">12.2.</span> <span class="toc-text">2.Sealed Classes（封闭类，预览）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Hidden-Classes%EF%BC%88%E9%9A%90%E8%97%8F%E7%B1%BB%EF%BC%89"><span class="toc-number">12.3.</span> <span class="toc-text">3. Hidden Classes（隐藏类）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Remove-the-Nashorn-JavaScript-Engine"><span class="toc-number">12.4.</span> <span class="toc-text">4. Remove the Nashorn JavaScript Engine</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Reimplement-the-Legacy-DatagramSocket-API%EF%BC%88%E9%87%8D%E6%96%B0%E5%AE%9E%E7%8E%B0DatagramSocket-API%EF%BC%89"><span class="toc-number">12.5.</span> <span class="toc-text">5.Reimplement the Legacy DatagramSocket API（重新实现DatagramSocket API）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%85%B6%E4%BB%96"><span class="toc-number">12.6.</span> <span class="toc-text">6.其他</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E4%B8%8E%E6%84%9F%E8%B0%A2"><span class="toc-number">13.</span> <span class="toc-text">参考与感谢</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AA%E4%BA%BA%E5%85%AC%E4%BC%97%E5%8F%B7"><span class="toc-number">14.</span> <span class="toc-text">个人公众号</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/06/19/JavaHome/%E7%BC%93%E5%AD%98Redis%E6%80%BB%E7%BB%93/%E4%B8%83%E7%A7%8D%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" title="七种方案对比分布式锁"><img src="/image/8.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="七种方案对比分布式锁"/></a><div class="content"><a class="title" href="/2022/06/19/JavaHome/%E7%BC%93%E5%AD%98Redis%E6%80%BB%E7%BB%93/%E4%B8%83%E7%A7%8D%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" title="七种方案对比分布式锁">七种方案对比分布式锁</a><time datetime="2022-06-19T13:50:08.178Z" title="发表于 2022-06-19 21:50:08">2022-06-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/19/JavaHome/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7%E7%AF%87/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80%EF%BC%9AGit%20%E5%91%BD%E4%BB%A4%E5%85%A8%E6%96%B9%E4%BD%8D%E5%AD%A6%E4%B9%A0/" title="程序员必备基础：Git 命令全方位学习"><img src="/image/5.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="程序员必备基础：Git 命令全方位学习"/></a><div class="content"><a class="title" href="/2022/06/19/JavaHome/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7%E7%AF%87/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80%EF%BC%9AGit%20%E5%91%BD%E4%BB%A4%E5%85%A8%E6%96%B9%E4%BD%8D%E5%AD%A6%E4%B9%A0/" title="程序员必备基础：Git 命令全方位学习">程序员必备基础：Git 命令全方位学习</a><time datetime="2022-06-19T13:50:08.178Z" title="发表于 2022-06-19 21:50:08">2022-06-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/19/JavaHome/%E7%BC%93%E5%AD%98Redis%E6%80%BB%E7%BB%93/%E4%BD%BF%E7%94%A8Redis%E7%9A%8421%E4%B8%AA%E6%B3%A8%E6%84%8F%E7%82%B9/" title="学习Redis相关知识"><img src="/image/7.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="学习Redis相关知识"/></a><div class="content"><a class="title" href="/2022/06/19/JavaHome/%E7%BC%93%E5%AD%98Redis%E6%80%BB%E7%BB%93/%E4%BD%BF%E7%94%A8Redis%E7%9A%8421%E4%B8%AA%E6%B3%A8%E6%84%8F%E7%82%B9/" title="学习Redis相关知识">学习Redis相关知识</a><time datetime="2022-06-19T13:50:08.178Z" title="发表于 2022-06-19 21:50:08">2022-06-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/19/JavaHome/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%8E%A5%E5%8F%A3%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%EF%BC%9A%E4%BC%98%E5%8C%96%E6%8E%A5%E5%8F%A3%E6%80%A7%E8%83%BD%E7%9A%84%E5%85%AB%E4%B8%AA%E5%BB%BA%E8%AE%AE/" title="记一次接口性能优化实践总结：优化接口性能的八个建议"><img src="https://t7.baidu.com/it/u=1723468391,764687099&amp;fm=193&amp;f=GIF" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="记一次接口性能优化实践总结：优化接口性能的八个建议"/></a><div class="content"><a class="title" href="/2022/06/19/JavaHome/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%8E%A5%E5%8F%A3%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%EF%BC%9A%E4%BC%98%E5%8C%96%E6%8E%A5%E5%8F%A3%E6%80%A7%E8%83%BD%E7%9A%84%E5%85%AB%E4%B8%AA%E5%BB%BA%E8%AE%AE/" title="记一次接口性能优化实践总结：优化接口性能的八个建议">记一次接口性能优化实践总结：优化接口性能的八个建议</a><time datetime="2022-06-19T13:50:08.177Z" title="发表于 2022-06-19 21:50:08">2022-06-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/19/JavaHome/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%90%E7%94%A8%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98/" title="线程池运用不当导致的问题"><img src="/image/5.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="线程池运用不当导致的问题"/></a><div class="content"><a class="title" href="/2022/06/19/JavaHome/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%90%E7%94%A8%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98/" title="线程池运用不当导致的问题">线程池运用不当导致的问题</a><time datetime="2022-06-19T13:50:08.177Z" title="发表于 2022-06-19 21:50:08">2022-06-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By woaker</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
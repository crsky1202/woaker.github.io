<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>volatile的学习 | 每天都不一样</title><meta name="keywords" content="程序员"><meta name="author" content="woaker"><meta name="copyright" content="woaker"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言volatile是Java程序员必备的基础，也是面试官非常喜欢问的一个话题，本文跟大家一起开启volatile学习之旅，如果有不正确的地方，也麻烦大家指出哈，一起相互学习~  1.volatile的用法 2.volatile变量的作用 3.现代计算机的内存模型（计算机模型，总线，MESI协议，嗅探技术） 4.Java内存模型（JMM） 5.并发编程的3个特性（原子性、可见性、有序性、happe">
<meta property="og:type" content="article">
<meta property="og:title" content="volatile的学习">
<meta property="og:url" content="http://example.com/2022/06/19/JavaHome/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%EF%BC%9AVolatile%E5%85%A8%E6%96%B9%E4%BD%8D%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="每天都不一样">
<meta property="og:description" content="前言volatile是Java程序员必备的基础，也是面试官非常喜欢问的一个话题，本文跟大家一起开启volatile学习之旅，如果有不正确的地方，也麻烦大家指出哈，一起相互学习~  1.volatile的用法 2.volatile变量的作用 3.现代计算机的内存模型（计算机模型，总线，MESI协议，嗅探技术） 4.Java内存模型（JMM） 5.并发编程的3个特性（原子性、可见性、有序性、happe">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/image/6.jpeg">
<meta property="article:published_time" content="2022-06-19T13:50:08.139Z">
<meta property="article:modified_time" content="2022-06-20T16:24:05.865Z">
<meta property="article:author" content="woaker">
<meta property="article:tag" content="程序员">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/image/6.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/06/19/JavaHome/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%EF%BC%9AVolatile%E5%85%A8%E6%96%B9%E4%BD%8D%E8%A7%A3%E6%9E%90/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'volatile的学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-06-21 00:24:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">135</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/List"><i class="fa-fw fas fa-list"></i><span> Study</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/image/6.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">每天都不一样</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/List"><i class="fa-fw fas fa-list"></i><span> Study</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">volatile的学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-06-19T13:50:08.139Z" title="发表于 2022-06-19 21:50:08">2022-06-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-06-20T16:24:05.865Z" title="更新于 2022-06-21 00:24:05">2022-06-21</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="volatile的学习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>volatile是Java程序员必备的基础，也是面试官非常喜欢问的一个话题，本文跟大家一起开启volatile学习之旅，如果有不正确的地方，也麻烦大家指出哈，一起相互学习~</p>
<ul>
<li>1.volatile的用法</li>
<li>2.volatile变量的作用</li>
<li>3.现代计算机的内存模型（计算机模型，总线，MESI协议，嗅探技术）</li>
<li>4.Java内存模型（JMM）</li>
<li>5.并发编程的3个特性（原子性、可见性、有序性、happen-before、as-if-serial、指令重排）</li>
<li>6.volatile的底层原理（如何保证可见性，如何保证指令重排，内存屏障）</li>
<li>7.volatile的典型场景（状态标志，DCL单例模式）</li>
<li>8.volatile常见面试题&amp;&amp;答案解析</li>
<li>公众号：捡田螺的小男孩</li>
</ul>
<p><strong>github 地址</strong></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/whx123/JavaHome">https://github.com/whx123/JavaHome</a></p>
</blockquote>
<h3 id="1-volatile的用法"><a href="#1-volatile的用法" class="headerlink" title="1.volatile的用法"></a>1.volatile的用法</h3><p>volatile关键字是Java虚拟机提供的的<strong>最轻量级的同步机制</strong>，它作为一个修饰符出现，用来<strong>修饰变量</strong>，但是这里不包括局部变量哦。我们来看个demo吧，代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  @Author 捡田螺的小男孩</span><br><span class="line"> *  @Date 2020/08/02</span><br><span class="line"> *  @Desc volatile的可见性探索</span><br><span class="line"> */</span><br><span class="line">public class VolatileTest  &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Task task = new Task();</span><br><span class="line"></span><br><span class="line">        Thread t1 = new Thread(task, &quot;线程t1&quot;);</span><br><span class="line">        Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                    System.out.println(&quot;开始通知线程停止&quot;);</span><br><span class="line">                    task.stop = true; //修改stop变量值。</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;线程t2&quot;);</span><br><span class="line">        t1.start();  //开启线程t1</span><br><span class="line">        t2.start();  //开启线程t2</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Task implements Runnable &#123;</span><br><span class="line">    boolean stop = false;</span><br><span class="line">    int i = 0;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        long s = System.currentTimeMillis();</span><br><span class="line">        while (!stop) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;线程退出&quot; + (System.currentTimeMillis() - s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果：</strong><br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/057e2eec568a40fe9f47e05f3b47bdb7~tplv-k3u1fbpfcp-zoom-1.image"><br>可以发现线程t2，虽然把stop设置为true了，但是线程t1对t2的<strong>stop变量视而不可见</strong>，因此，它一直在死循环running中。如果给变量stop加上volatile修饰，线程t1是可以停下来的,运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatile boolean stop = false;</span><br></pre></td></tr></table></figure>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81326a66e9cc4350af71b0e9ff4dc304~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h3 id="2-vlatile修饰变量的作用"><a href="#2-vlatile修饰变量的作用" class="headerlink" title="2. vlatile修饰变量的作用"></a>2. vlatile修饰变量的作用</h3><p>从以上例子，我们可以发现变量stop，加了vlatile修饰之后，线程t1对stop就可见了。其实，vlatile的作用就是：<strong>保证变量对所有线程可见性</strong>。当然，vlatile还有个作用就是，<strong>禁止指令重排</strong>，但是它<strong>不保证原子性</strong>。<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5177218cf2b491da99d43392c7bd271~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>所以当面试官问你<strong>volatile的作用或者特性</strong>，都可以这么回答：</p>
<ul>
<li>保证变量对所有线程可见性;</li>
<li>禁止指令重排序</li>
<li>不保证原子性</li>
</ul>
<h3 id="3-现代计算机的内存模型（计算机模型，MESI协议，嗅探技术，总线）"><a href="#3-现代计算机的内存模型（计算机模型，MESI协议，嗅探技术，总线）" class="headerlink" title="3. 现代计算机的内存模型（计算机模型，MESI协议，嗅探技术，总线）"></a>3. 现代计算机的内存模型（计算机模型，MESI协议，嗅探技术，总线）</h3><p>为了更好理解volatile，先回顾一下计算机的内存模型与JMM（Java内存模型）吧~</p>
<h4 id="计算机模型"><a href="#计算机模型" class="headerlink" title="计算机模型"></a>计算机模型</h4><p>计算机执行程序时，指令是由CPU处理器执行的，而打交道的数据是在主内存当中的。</p>
<p>由于计算机的存储设备与处理器的运算速度有几个数量级的差距，总不能每次CPU执行完指令，然后等主内存慢悠悠存取数据吧，<br>所以现代计算机系统加入一层读写速度接近处理器运算速度的高速缓存（Cache），以作为来作为内存与处理器之间的缓冲。</p>
<p>在多路处理器系统中，每个处理器都有自己的高速缓存，而它们共享同一主内存。<strong>计算机抽象内存模型</strong>如下：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f995fb284a7241b9b95431e79a1c37b0~tplv-k3u1fbpfcp-zoom-1.image"></p>
<ul>
<li>程序执行时，把需要用到的数据，从主内存拷贝一份到高速缓存。</li>
<li>CPU处理器计算时，从它的高速缓存中读取，把计算完的数据写入高速缓存。</li>
<li>当程序运算结束，把高速缓存的数据刷新会主内存。</li>
</ul>
<p>随着科学技术的发展，为了效率，高速缓存又衍生出一级缓存（L1），二级缓存（L2），甚至三级缓存(L3);<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05fa9ff22d7f42ae82122bfc6c233bd9~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>当多个处理器的运算任务都涉及同一块主内存区域，可能导致<strong>缓存数据不一致</strong>问题。如何解决这个问题呢？有两种方案</p>
<blockquote>
<ul>
<li>1、通过在总线加LOCK#锁的方式。</li>
<li>2、通过缓存一致性协议（Cache Coherence Protocol）</li>
</ul>
</blockquote>
<h4 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h4><blockquote>
<p>总线（Bus）是计算机各种功能部件之间传送信息的公共通信干线，它是由导线组成的传输线束， 按照计算机所传输的信息种类，计算机的总线可以划分为数据总线、地址总线和控制总线，分别用来传输数据、数据地址和控制信号。</p>
</blockquote>
<p>CPU和其他功能部件是通过总线通信的，如果在总线加LOCK#锁，那么在锁住总线期间，其他CPU是无法访问内存，这样一来，<strong>效率就比较低了</strong>。</p>
<h4 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h4><p>为了解决一致性问题，还可以通过缓存一致性协议。即各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（IllinoisProtocol）、MOSI、Synapse、Firefly及DragonProtocol等。比较著名的就是Intel的MESI（Modified Exclusive Shared Or Invalid）协议，它的核心思想是：</p>
<blockquote>
<p> 当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p>
</blockquote>
<p>CPU中每个缓存行标记的4种状态（M、E、S、I）,也了解一下吧:</p>
<table>
<thead>
<tr>
<th>缓存状态</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>M，被修改（Modified)</td>
<td>该缓存行只被该CPU缓存，与主存的值不同，会在它被其他CPU读取之前写入内存，并设置为Shared</td>
</tr>
<tr>
<td>E，独享的（Exclusive)</td>
<td>该缓存行只被该CPU缓存，与主存的值相同，被其他CPU读取时置为Shared，被其他CPU写时置为Modified</td>
</tr>
<tr>
<td>S，共享的（Shared)</td>
<td>该缓存行可能被多个CPU缓存，各个缓存中的数据与主存数据相同</td>
</tr>
<tr>
<td>I，无效的（Invalid）</td>
<td>该缓存行数据是无效，需要时需重新从主存载入</td>
</tr>
</tbody></table>
<p>MESI协议是如何实现的？如何保证当前处理器的内部缓存、主内存和其他处理器的缓存数据在总线上保持一致的？<strong>多处理器总线嗅探</strong></p>
<h4 id="嗅探技术"><a href="#嗅探技术" class="headerlink" title="嗅探技术"></a>嗅探技术</h4><blockquote>
<p>在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己的缓存值是不是过期了，如果处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据库读到处理器缓存中。</p>
</blockquote>
<h3 id="4-Java内存模型（JMM）"><a href="#4-Java内存模型（JMM）" class="headerlink" title="4. Java内存模型（JMM）"></a>4. Java内存模型（JMM）</h3><ul>
<li>Java虚拟机规范试图定义一种Java内存模型,来<strong>屏蔽掉各种硬件和操作系统的内存访问差异</strong>，以实现让Java程序在各种平台上都能达到一致的内存访问效果。</li>
<li>Java内存模型<strong>类比</strong>于计算机内存模型。</li>
<li>为了更好的执行性能，java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存打交道，也没有限制编译器进行调整代码顺序优化。所以Java内存模型<strong>会存在缓存一致性问题和指令重排序问题的</strong>。</li>
<li>Java内存模型规定所有的变量都是存在主内存当中（类似于计算机模型中的物理内存），每个线程都有自己的工作内存（类似于计算机模型的高速缓存）。这里的<strong>变量</strong>包括实例变量和静态变量，但是<strong>不包括局部变量</strong>，因为局部变量是线程私有的。</li>
<li>线程的工作内存保存了被该线程使用的变量的主内存副本，<strong>线程对变量的所有操作都必须在工作内存中进行</strong>，而不能直接操作操作主内存。并且每个线程不能访问其他线程的工作内存。</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6ca8c98a8cc42c998dd4fe3324ded79~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>举个例子吧，假设i的初始值是0，执行以下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = i+1;</span><br></pre></td></tr></table></figure>
<p>首先，执行线程t1从主内存中读取到i&#x3D;0，到工作内存。然后在工作内存中，赋值i+1,工作内存就得到i&#x3D;1，最后把结果写回主内存。因此，如果是单线程的话，该语句执行是没问题的。但是呢，线程t2的本地工作内存还没过期，那么它读到的数据就是脏数据了。如图：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0abe171336e4f89a58722a1569d64ce~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>Java内存模型是围绕着如何在并发过程中如何处理<strong>原子性、可见性和有序性</strong>这3个特征来建立的，我们再来一起回顾一下~</p>
<h3 id="5-并发编程的3个特性（原子性、可见性、有序性）"><a href="#5-并发编程的3个特性（原子性、可见性、有序性）" class="headerlink" title="5.并发编程的3个特性（原子性、可见性、有序性）"></a>5.并发编程的3个特性（原子性、可见性、有序性）</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>原子性，指操作是不可中断的，要么执行完成，要么不执行，基本数据类型的访问和读写都是具有原子性，当然（long和double的非原子性协定除外）。我们来看几个小例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i =666； // 语句1</span><br><span class="line">i = j;   // 语句2</span><br><span class="line">i = i+1;  //语句 3</span><br><span class="line">i++;   // 语句4</span><br></pre></td></tr></table></figure>
<ul>
<li>语句1操作显然是原子性的，将数值666赋值给i，即线程执行这个语句时，直接将数值666写入到工作内存中。</li>
<li>语句2操作看起来也是原子性的，但是它实际上涉及两个操作，先去读j的值，再把j的值写入工作内存，两个操作分开都是原子操作，但是合起来就不满足原子性了。</li>
<li>语句3读取i的值，加1，再写回主存，这个就不是原子性操作了。</li>
<li>语句4 等同于语句3，也是非原子性操作。</li>
</ul>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><ul>
<li>可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。</li>
<li>Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此。</li>
<li>volatile变量，保证新值能立即同步回主内存，以及每次使用前立即从主内存刷新，所以我们说volatile保证了多线程操作变量的可见性。</li>
<li>synchronized和Lock也能够保证可见性，线程在释放锁之前，会把共享变量值都刷回主存。final也可以实现可见性。</li>
</ul>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>Java虚拟机这样描述Java程序的有序性的：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中，观察另一个线程，所有的操作都是无序的。</p>
<p>后半句意思就是，在Java内存模型中，<strong>允许编译器和处理器对指令进行重排序</strong>，会影响到多线程并发执行的正确性；前半句意思就是<strong>as-if-serial</strong>的语义，即不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不会被改变。</p>
<p>比如以下程序代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double pi  = 3.14;    //A</span><br><span class="line">double r   = 1.0;     //B</span><br><span class="line">double area = pi * r * r; //C</span><br></pre></td></tr></table></figure>
<p>步骤C依赖于步骤A和B，因为指令重排的存在，程序执行顺讯可能是A-&gt;B-&gt;C,也可能是B-&gt;A-&gt;C,但是C不能在A或者B前面执行，这将违反as-if-serial语义。<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87387195b86749ddbe1f36582a562988~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>看段代码吧，假设程序先执行read方法，再执行add方法，结果一定是输出sum&#x3D;2嘛？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool flag = false;</span><br><span class="line">int b = 0;</span><br><span class="line"></span><br><span class="line">public void read() &#123;</span><br><span class="line">   b = 1;              //1</span><br><span class="line">   flag = true;        //2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void add() &#123;</span><br><span class="line">   if (flag) &#123;         //3</span><br><span class="line">       int sum =b+b;   //4</span><br><span class="line">       System.out.println(&quot;bb sum is&quot;+sum); </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果是单线程，结果应该没问题，如果是多线程，线程t1对步骤1和2进行了<strong>指令重排序</strong>呢？结果sum就不是2了，而是0，如下图所示：<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/093c6e37453c462985bed78c4d239979~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>这是为啥呢？<strong>指令重排序</strong>了解一下，指令重排是指在程序执行过程中,<strong>为了提高性能</strong>, <strong>编译器和CPU可能会对指令进行重新排序</strong>。CPU重排序包括指令并行重排序和内存系统重排序，重排序类型和重排序执行过程如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8a24934eab24bf9b80c402039371aa2~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>实际上，可以给flag加上volatile关键字，来保证有序性。当然，也可以通过synchronized和Lock来保证有序性。synchronized和Lock保证某一时刻是只有一个线程执行同步代码，相当于是让线程顺序执行程序代码了，自然就保证了有序性。</p>
<p>实际上Java内存模型的有序性并不是仅靠volatile、synchronized和Lock来保证有序性的。这是因为Java语言中，有一个先行发生原则（happens-before）：</p>
<ul>
<li><strong>程序次序规则</strong>：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。</li>
<li><strong>管程锁定规则</strong>：一个unLock操作先行发生于后面对同一个锁额lock操作</li>
<li><strong>volatile变量规则</strong>：对一个变量的写操作先行发生于后面对这个变量的读操作</li>
<li><strong>线程启动规则</strong>：Thread对象的start()方法先行发生于此线程的每个一个动作</li>
<li><strong>线程终止规则</strong>：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li>
<li><strong>线程中断规则</strong>：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li>
<li><strong>对象终结规则</strong>：一个对象的初始化完成先行发生于他的finalize()方法的开始</li>
<li><strong>传递性</strong>：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li>
</ul>
<p>根据happens-before的八大规则，我们回到刚的例子，一起分析一下。给flag加上volatile关键字，look look它是如何保证有序性的，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">volatile bool flag = false;</span><br><span class="line">int b = 0;</span><br><span class="line"></span><br><span class="line">public void read() &#123;</span><br><span class="line">   b = 1;              //1</span><br><span class="line">   flag = true;        //2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void add() &#123;</span><br><span class="line">   if (flag) &#123;         //3</span><br><span class="line">       int sum =b+b;   //4</span><br><span class="line">       System.out.println(&quot;bb sum is&quot;+sum); </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先呢，flag加上volatile关键字，那就禁止了指令重排，也就是1 happens-before 2了</li>
<li>根据<strong>volatile变量规则</strong>，2 happens-before 3</li>
<li>由<strong>程序次序规则</strong>，得出 3 happens-before 4</li>
<li>最后由<strong>传递性</strong>，得出1 happens-before 4，因此妥妥的输出sum&#x3D;2啦~</li>
</ul>
<h3 id="6-volatile底层原理"><a href="#6-volatile底层原理" class="headerlink" title="6.volatile底层原理"></a>6.volatile底层原理</h3><p>以上讨论学习，我们知道volatile的语义就是保证变量对所有线程可见性以及禁止指令重排优化。那么，它的底层是如何保证可见性和禁止指令重排的呢？</p>
<h4 id="图解volatile是如何保证可见性的？"><a href="#图解volatile是如何保证可见性的？" class="headerlink" title="图解volatile是如何保证可见性的？"></a>图解volatile是如何保证可见性的？</h4><p>在这里，先看几个图吧，哈哈~</p>
<p>假设flag变量的初始值false，现在有两条线程t1和t2要访问它，就可以简化为以下图：<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ddbe230c8dc4501a77ffbe0587b5ba6~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>如果线程t1执行以下代码语句，并且flag没有volatile修饰的话；t1刚修改完flag的值，还没来得及刷新到主内存，t2又跑过来读取了，很容易就数据flag不一致了，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag=true;</span><br></pre></td></tr></table></figure>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc065cf75803496aa1efafd6d68ba968~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>如果flag变量是由volatile修饰的话，就不一样了，如果线程t1修改了flag值，volatile能保证修饰的flag变量后，可以<strong>立即同步回主内存</strong>。如图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27e9e195810a4a71bdeb38dd128b27e4~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>细心的朋友会发现，线程t2不还是flag旧的值吗，这不还有问题嘛？其实volatile还有一个保证，就是<strong>每次使用前立即先从主内存刷新最新的值</strong>，线程t1修改完后，线程t2的变量副本会过期了，如图：<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e67dcdfe9d9412dab89961bf92b5b53~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>显然，这里还不是底层，实际上volatile保证可见性和禁止指令重排都跟<strong>内存屏障</strong>有关，我们编译volatile相关代码看看~</p>
<h4 id="DCL单例模式（volatile）-amp-编译对比"><a href="#DCL单例模式（volatile）-amp-编译对比" class="headerlink" title="DCL单例模式（volatile）&amp;编译对比"></a>DCL单例模式（volatile）&amp;编译对比</h4><p>DCL单例模式（Double Check Lock，双重检查锁）比较常用，它是需要volatile修饰的，所以就拿这段代码编译吧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private volatile static Singleton instance;  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    public static Singleton getInstance() &#123;  </span><br><span class="line">    if (instance == null) &#123;  </span><br><span class="line">        synchronized (Singleton.class) &#123;  </span><br><span class="line">        if (instance == null) &#123;  </span><br><span class="line">            instance = new Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>编译这段代码后，观察有volatile关键字和没有volatile关键字时的instance所生成的汇编代码发现，有volatile关键字修饰时，会多出一个lock addl $0x0,(%esp)，即多出一个lock前缀指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x01a3de0f: mov    $0x3375cdb0,%esi   ;...beb0cd75 33  </span><br><span class="line">                                        ;   &#123;oop(&#x27;Singleton&#x27;)&#125;  </span><br><span class="line">0x01a3de14: mov    %eax,0x150(%esi)   ;...89865001 0000  </span><br><span class="line">0x01a3de1a: shr    $0x9,%esi          ;...c1ee09  </span><br><span class="line">0x01a3de1d: movb   $0x0,0x1104800(%esi)  ;...c6860048 100100  </span><br><span class="line">0x01a3de24: lock addl $0x0,(%esp)     ;...f0830424 00  </span><br><span class="line">                                        ;*putstatic instance  </span><br><span class="line">                                        ; - Singleton::getInstance@24 </span><br></pre></td></tr></table></figure>
<p> lock指令相当于一个<strong>内存屏障</strong>，它保证以下这几点：</p>
<blockquote>
<ul>
<li>1.重排序时不能把后面的指令重排序到内存屏障之前的位置</li>
<li>2.将本处理器的缓存写入内存</li>
<li>3.如果是写入动作，会导致其他处理器中对应的缓存无效。</li>
</ul>
</blockquote>
<p>显然，第2、3点不就是volatile保证可见性的体现嘛，第1点就是禁止指令重排列的体现。</p>
<h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h4><p>内存屏障四大分类：（Load 代表读取指令，Store代表写入指令）</p>
<table>
<thead>
<tr>
<th>内存屏障类型</th>
<th>抽象场景</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>LoadLoad屏障</td>
<td>Load1; LoadLoad; Load2</td>
<td>在Load2要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</td>
</tr>
<tr>
<td>StoreStore屏障</td>
<td>Store1; StoreStore; Store2</td>
<td>在Store2写入执行前，保证Store1的写入操作对其它处理器可见</td>
</tr>
<tr>
<td>LoadStore屏障</td>
<td>Load1; LoadStore; Store2</td>
<td>在Store2被写入前，保证Load1要读取的数据被读取完毕。</td>
</tr>
<tr>
<td>StoreLoad屏障</td>
<td>Store1; StoreLoad; Load2</td>
<td>在Load2读取操作执行前，保证Store1的写入对所有处理器可见。</td>
</tr>
</tbody></table>
<p>为了实现volatile的内存语义，Java内存模型采取以下的保守策略</p>
<ul>
<li>在每个volatile写操作的前面插入一个StoreStore屏障。</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障。</li>
</ul>
<p>有些小伙伴，可能对这个还是有点疑惑，内存屏障这玩意太抽象了。我们照着代码看下吧（LoadLoad内存屏障也是在flag后面哈，图片有误）：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a85eff53f99f420c8139bb69b2d4f6ae~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>内存屏障保证前面的指令先执行，所以这就保证了禁止了指令重排啦，同时内存屏障保证缓存写入内存和其他处理器缓存失效，这也就保证了可见性，哈哈~</p>
<h3 id="7-volatile的典型场景"><a href="#7-volatile的典型场景" class="headerlink" title="7.volatile的典型场景"></a>7.volatile的典型场景</h3><p>通常来说，使用volatile必须具备以下2个条件：</p>
<ul>
<li>1）对变量的写操作不依赖于当前值</li>
<li>2）该变量没有包含在具有其他变量的不变式中</li>
</ul>
<p>实际上，volatile场景一般就是<strong>状态标志</strong>，以及<strong>DCL单例模式</strong>。</p>
<h4 id="7-1-状态标志"><a href="#7-1-状态标志" class="headerlink" title="7.1 状态标志"></a>7.1 状态标志</h4><p>深入理解Java虚拟机，书中的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Map configOptions;</span><br><span class="line">char[] configText;</span><br><span class="line">// 此变量必须定义为 volatile</span><br><span class="line">volatile boolean initialized = false;</span><br><span class="line"></span><br><span class="line">// 假设以下代码在线程 A 中运行</span><br><span class="line">// 模拟读取配置信息, 当读取完成后将 initialized 设置为 true 以告知其他线程配置可用</span><br><span class="line">configOptions = new HashMap();</span><br><span class="line">configText = readConfigFile(fileName);</span><br><span class="line">processConfigOptions(configText, configOptions);</span><br><span class="line">initialized = true;</span><br><span class="line">      </span><br><span class="line">// 假设以下代码在线程 B 中运行</span><br><span class="line">// 等待 initialized 为 true, 代表线程 A 已经把配置信息初始化完成</span><br><span class="line">while(!initialized) &#123;</span><br><span class="line">   sleep();</span><br><span class="line">&#125;</span><br><span class="line">// 使用线程 A 中初始化好的配置信息</span><br><span class="line">doSomethingWithConfig();</span><br></pre></td></tr></table></figure>
<h4 id="7-2-DCL单例模式"><a href="#7-2-DCL单例模式" class="headerlink" title="7.2 DCL单例模式"></a>7.2 DCL单例模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Singleton&#123;</span><br><span class="line">    private volatile static Singleton instance = null;</span><br><span class="line">     </span><br><span class="line">    private Singleton() &#123;   </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if(instance==null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if(instance==null)</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="8-volatile相关经典面试题"><a href="#8-volatile相关经典面试题" class="headerlink" title="8. volatile相关经典面试题"></a>8. volatile相关经典面试题</h3><ul>
<li>谈谈volatile的特性</li>
<li>volatile的内存语义  </li>
<li>说说并发编程的3大特性</li>
<li>什么是内存可见性，什么是指令重排序？</li>
<li>volatile是如何解决java并发中可见性的问题</li>
<li>volatile如何防止指令重排</li>
<li>volatile可以解决原子性嘛？为什么？</li>
<li>volatile底层的实现机制</li>
<li>volatile和synchronized的区别？</li>
</ul>
<h4 id="8-1-谈谈volatile的特性"><a href="#8-1-谈谈volatile的特性" class="headerlink" title="8.1 谈谈volatile的特性"></a>8.1 谈谈volatile的特性</h4><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e624231e978455ebec33c7380ffba0d~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h4 id="8-2-volatile的内存语义"><a href="#8-2-volatile的内存语义" class="headerlink" title="8.2  volatile的内存语义"></a>8.2  volatile的内存语义</h4><ul>
<li>当写一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量值刷新到主内存。</li>
<li>当读一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</li>
</ul>
<h4 id="8-3-说说并发编程的3大特性"><a href="#8-3-说说并发编程的3大特性" class="headerlink" title="8.3 说说并发编程的3大特性"></a>8.3 说说并发编程的3大特性</h4><ul>
<li>原子性</li>
<li>可见性</li>
<li>有序性</li>
</ul>
<h4 id="8-4-什么是内存可见性，什么是指令重排序？"><a href="#8-4-什么是内存可见性，什么是指令重排序？" class="headerlink" title="8.4 什么是内存可见性，什么是指令重排序？"></a>8.4 什么是内存可见性，什么是指令重排序？</h4><ul>
<li>可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。</li>
<li>指令重排是指JVM在编译Java代码的时候，或者CPU在执行JVM字节码的时候，对现有的指令顺序进行重新排序。</li>
</ul>
<h4 id="8-5-volatile是如何解决java并发中可见性的问题"><a href="#8-5-volatile是如何解决java并发中可见性的问题" class="headerlink" title="8.5 volatile是如何解决java并发中可见性的问题"></a>8.5 volatile是如何解决java并发中可见性的问题</h4><p>底层是通过内存屏障实现的哦，volatile能保证修饰的变量后，可以立即同步回主内存，每次使用前立即先从主内存刷新最新的值。</p>
<h4 id="8-6-volatile如何防止指令重排"><a href="#8-6-volatile如何防止指令重排" class="headerlink" title="8.6 volatile如何防止指令重排"></a>8.6 volatile如何防止指令重排</h4><p>也是内存屏障哦，跟面试官讲下Java内存的保守策略：</p>
<ul>
<li>在每个volatile写操作的前面插入一个StoreStore屏障。</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障。</li>
</ul>
<p>再讲下volatile的语义哦，重排序时不能把内存屏障后面的指令重排序到内存屏障之前的位置</p>
<h4 id="8-7-volatile可以解决原子性嘛？为什么？"><a href="#8-7-volatile可以解决原子性嘛？为什么？" class="headerlink" title="8.7 volatile可以解决原子性嘛？为什么？"></a>8.7 volatile可以解决原子性嘛？为什么？</h4><p>不可以，可以直接举i++那个例子，原子性需要synchronzied或者lock保证</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public volatile int race = 0;</span><br><span class="line">     </span><br><span class="line">    public void increase() &#123;</span><br><span class="line">        race++;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread()&#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j=0;j&lt;100;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //等待所有累加线程结束</span><br><span class="line">        while(Thread.activeCount()&gt;1)  </span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.race);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-8-volatile底层的实现机制"><a href="#8-8-volatile底层的实现机制" class="headerlink" title="8.8 volatile底层的实现机制"></a>8.8 volatile底层的实现机制</h4><p> 可以看本文的第六小节，volatile底层原理哈，主要你要跟面试官讲述，volatile如何保证可见性和禁止指令重排，需要讲到内存屏障~</p>
<h4 id="8-9-volatile和synchronized的区别？"><a href="#8-9-volatile和synchronized的区别？" class="headerlink" title="8.9 volatile和synchronized的区别？"></a>8.9 volatile和synchronized的区别？</h4><ul>
<li>volatile修饰的是变量，synchronized一般修饰代码块或者方法</li>
<li>volatile保证可见性、禁止指令重排，但是不保证原子性；synchronized可以保证原子性</li>
<li>volatile不会造成线程阻塞，synchronized可能会造成线程的阻塞，所以后面才有锁优化那么多故事~</li>
<li>哈哈，你还有补充嘛~</li>
</ul>
<p>推荐之前写的一篇文章：<br><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903918653145102">Synchronized解析——如果你愿意一层一层剥开我的心</a></p>
<h3 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07e9fd0521c244adab8556fee99a2011~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h3 id="参考与感谢"><a href="#参考与感谢" class="headerlink" title="参考与感谢"></a>参考与感谢</h3><ul>
<li>&lt;&lt;深入理解Java虚拟机&gt;&gt;</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dolphin0520/p/3920373.html">Java并发编程：volatile关键字解析</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903520760496141">面试官最爱的volatile关键字</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/6844904149536997384"> 面试官没想到一个Volatile，我都能跟他扯半小时</a></li>
<li><a target="_blank" rel="noopener" href="http://47.103.216.138/archives/2550">再有人问你Java内存模型是什么，就把这篇文章发给他。</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/z00377750/p/9180644.html">【并发编程】MESI–CPU缓存一致性协议</a></li>
<li><a target="_blank" rel="noopener" href="https://www.sohu.com/a/211287207_684445">漫画：volatile对指令重排的影响 </a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/765e3abbe89a">volatile三大特性详解</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">woaker</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/06/19/JavaHome/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%EF%BC%9AVolatile%E5%85%A8%E6%96%B9%E4%BD%8D%E8%A7%A3%E6%9E%90/">http://example.com/2022/06/19/JavaHome/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%EF%BC%9AVolatile%E5%85%A8%E6%96%B9%E4%BD%8D%E8%A7%A3%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">每天都不一样</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/image/6.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/06/19/JavaHome/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%E7%9A%84%E5%9F%BA%E7%A1%80%E6%B5%81%E7%A8%8B%E5%9B%BE/"><img class="prev-cover" src="/image/11.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java程序员必备的基础流程图</div></div></a></div><div class="next-post pull-right"><a href="/2022/06/19/JavaHome/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%EF%BC%9A%E5%BC%82%E5%B8%B8%E7%9A%84%E5%8D%81%E4%B8%AA%E5%85%B3%E9%94%AE%E7%9F%A5%E8%AF%86%E7%82%B9/"><img class="next-cover" src="/image/8.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java程序员必备：异常的十个关键知识点</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">woaker</div><div class="author-info__description">不积跬步无以至千里</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">135</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/woaker"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-volatile%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">1.volatile的用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-vlatile%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">2. vlatile修饰变量的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A8%A1%E5%9E%8B%EF%BC%8CMESI%E5%8D%8F%E8%AE%AE%EF%BC%8C%E5%97%85%E6%8E%A2%E6%8A%80%E6%9C%AF%EF%BC%8C%E6%80%BB%E7%BA%BF%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">3. 现代计算机的内存模型（计算机模型，MESI协议，嗅探技术，总线）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">计算机模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF"><span class="toc-number">4.2.</span> <span class="toc-text">总线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MESI%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.3.</span> <span class="toc-text">MESI协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%97%85%E6%8E%A2%E6%8A%80%E6%9C%AF"><span class="toc-number">4.4.</span> <span class="toc-text">嗅探技术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88JMM%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">4. Java内存模型（JMM）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%843%E4%B8%AA%E7%89%B9%E6%80%A7%EF%BC%88%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">5.并发编程的3个特性（原子性、可见性、有序性）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">6.1.</span> <span class="toc-text">原子性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">6.2.</span> <span class="toc-text">可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">6.3.</span> <span class="toc-text">有序性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-volatile%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">6.volatile底层原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E8%A7%A3volatile%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7%E7%9A%84%EF%BC%9F"><span class="toc-number">7.1.</span> <span class="toc-text">图解volatile是如何保证可见性的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DCL%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88volatile%EF%BC%89-amp-%E7%BC%96%E8%AF%91%E5%AF%B9%E6%AF%94"><span class="toc-number">7.2.</span> <span class="toc-text">DCL单例模式（volatile）&amp;编译对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="toc-number">7.3.</span> <span class="toc-text">内存屏障</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-volatile%E7%9A%84%E5%85%B8%E5%9E%8B%E5%9C%BA%E6%99%AF"><span class="toc-number">8.</span> <span class="toc-text">7.volatile的典型场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-%E7%8A%B6%E6%80%81%E6%A0%87%E5%BF%97"><span class="toc-number">8.1.</span> <span class="toc-text">7.1 状态标志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-DCL%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.2.</span> <span class="toc-text">7.2 DCL单例模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-volatile%E7%9B%B8%E5%85%B3%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">9.</span> <span class="toc-text">8. volatile相关经典面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-%E8%B0%88%E8%B0%88volatile%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">9.1.</span> <span class="toc-text">8.1 谈谈volatile的特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-volatile%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89"><span class="toc-number">9.2.</span> <span class="toc-text">8.2  volatile的内存语义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-%E8%AF%B4%E8%AF%B4%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%843%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">9.3.</span> <span class="toc-text">8.3 说说并发编程的3大特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%EF%BC%9F"><span class="toc-number">9.4.</span> <span class="toc-text">8.4 什么是内存可见性，什么是指令重排序？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-volatile%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3java%E5%B9%B6%E5%8F%91%E4%B8%AD%E5%8F%AF%E8%A7%81%E6%80%A7%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">9.5.</span> <span class="toc-text">8.5 volatile是如何解决java并发中可见性的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-volatile%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92"><span class="toc-number">9.6.</span> <span class="toc-text">8.6 volatile如何防止指令重排</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-7-volatile%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3%E5%8E%9F%E5%AD%90%E6%80%A7%E5%98%9B%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">9.7.</span> <span class="toc-text">8.7 volatile可以解决原子性嘛？为什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-8-volatile%E5%BA%95%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">9.8.</span> <span class="toc-text">8.8 volatile底层的实现机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-9-volatile%E5%92%8Csynchronized%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">9.9.</span> <span class="toc-text">8.9 volatile和synchronized的区别？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E4%BC%97%E5%8F%B7"><span class="toc-number">10.</span> <span class="toc-text">公众号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E4%B8%8E%E6%84%9F%E8%B0%A2"><span class="toc-number">11.</span> <span class="toc-text">参考与感谢</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/06/19/JavaHome/%E7%BC%93%E5%AD%98Redis%E6%80%BB%E7%BB%93/%E4%B8%83%E7%A7%8D%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" title="七种方案对比分布式锁"><img src="/image/8.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="七种方案对比分布式锁"/></a><div class="content"><a class="title" href="/2022/06/19/JavaHome/%E7%BC%93%E5%AD%98Redis%E6%80%BB%E7%BB%93/%E4%B8%83%E7%A7%8D%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" title="七种方案对比分布式锁">七种方案对比分布式锁</a><time datetime="2022-06-19T13:50:08.178Z" title="发表于 2022-06-19 21:50:08">2022-06-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/19/JavaHome/%E7%BC%93%E5%AD%98Redis%E6%80%BB%E7%BB%93/%E4%BD%BF%E7%94%A8Redis%E7%9A%8421%E4%B8%AA%E6%B3%A8%E6%84%8F%E7%82%B9/" title="学习Redis相关知识"><img src="/image/7.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="学习Redis相关知识"/></a><div class="content"><a class="title" href="/2022/06/19/JavaHome/%E7%BC%93%E5%AD%98Redis%E6%80%BB%E7%BB%93/%E4%BD%BF%E7%94%A8Redis%E7%9A%8421%E4%B8%AA%E6%B3%A8%E6%84%8F%E7%82%B9/" title="学习Redis相关知识">学习Redis相关知识</a><time datetime="2022-06-19T13:50:08.178Z" title="发表于 2022-06-19 21:50:08">2022-06-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/19/JavaHome/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7%E7%AF%87/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80%EF%BC%9AGit%20%E5%91%BD%E4%BB%A4%E5%85%A8%E6%96%B9%E4%BD%8D%E5%AD%A6%E4%B9%A0/" title="程序员必备基础：Git 命令全方位学习"><img src="/image/5.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="程序员必备基础：Git 命令全方位学习"/></a><div class="content"><a class="title" href="/2022/06/19/JavaHome/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7%E7%AF%87/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80%EF%BC%9AGit%20%E5%91%BD%E4%BB%A4%E5%85%A8%E6%96%B9%E4%BD%8D%E5%AD%A6%E4%B9%A0/" title="程序员必备基础：Git 命令全方位学习">程序员必备基础：Git 命令全方位学习</a><time datetime="2022-06-19T13:50:08.178Z" title="发表于 2022-06-19 21:50:08">2022-06-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/19/JavaHome/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%8E%A5%E5%8F%A3%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%EF%BC%9A%E4%BC%98%E5%8C%96%E6%8E%A5%E5%8F%A3%E6%80%A7%E8%83%BD%E7%9A%84%E5%85%AB%E4%B8%AA%E5%BB%BA%E8%AE%AE/" title="记一次接口性能优化实践总结：优化接口性能的八个建议"><img src="https://t7.baidu.com/it/u=1723468391,764687099&amp;fm=193&amp;f=GIF" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="记一次接口性能优化实践总结：优化接口性能的八个建议"/></a><div class="content"><a class="title" href="/2022/06/19/JavaHome/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%8E%A5%E5%8F%A3%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%EF%BC%9A%E4%BC%98%E5%8C%96%E6%8E%A5%E5%8F%A3%E6%80%A7%E8%83%BD%E7%9A%84%E5%85%AB%E4%B8%AA%E5%BB%BA%E8%AE%AE/" title="记一次接口性能优化实践总结：优化接口性能的八个建议">记一次接口性能优化实践总结：优化接口性能的八个建议</a><time datetime="2022-06-19T13:50:08.177Z" title="发表于 2022-06-19 21:50:08">2022-06-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/19/JavaHome/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F&amp;%E9%9D%A2%E8%AF%95%E5%BB%BA%E8%AE%AE/%E9%87%91%E4%B8%89%E9%93%B6%E5%9B%9B%EF%BC%8C%E7%BB%99%E9%9D%A2%E8%AF%95%E8%80%85%E7%9A%84%E5%8D%81%E5%A4%A7%E5%BB%BA%E8%AE%AE/" title="金三银四，给面试者的十大建议"><img src="/image/12.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="金三银四，给面试者的十大建议"/></a><div class="content"><a class="title" href="/2022/06/19/JavaHome/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F&amp;%E9%9D%A2%E8%AF%95%E5%BB%BA%E8%AE%AE/%E9%87%91%E4%B8%89%E9%93%B6%E5%9B%9B%EF%BC%8C%E7%BB%99%E9%9D%A2%E8%AF%95%E8%80%85%E7%9A%84%E5%8D%81%E5%A4%A7%E5%BB%BA%E8%AE%AE/" title="金三银四，给面试者的十大建议">金三银四，给面试者的十大建议</a><time datetime="2022-06-19T13:50:08.177Z" title="发表于 2022-06-19 21:50:08">2022-06-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By woaker</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
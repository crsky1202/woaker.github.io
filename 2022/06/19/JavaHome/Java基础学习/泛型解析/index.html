<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>泛型解析 | 每天都不一样</title><meta name="keywords" content="程序员"><meta name="author" content="woaker"><meta name="copyright" content="woaker"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言整理了Java泛型的相关知识，算是比较基础的，希望大家一起学习进步。 一、什么是Java泛型Java 泛型（generics）是 JDK 5 中引入的一个新特性，其本质是参数化类型，解决不确定具体对象类型的问题。其所操作的数据类型被指定为一个参数（type parameter）这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。 泛型类泛型类（generic cla">
<meta property="og:type" content="article">
<meta property="og:title" content="泛型解析">
<meta property="og:url" content="http://example.com/2022/06/19/JavaHome/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/%E6%B3%9B%E5%9E%8B%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="每天都不一样">
<meta property="og:description" content="前言整理了Java泛型的相关知识，算是比较基础的，希望大家一起学习进步。 一、什么是Java泛型Java 泛型（generics）是 JDK 5 中引入的一个新特性，其本质是参数化类型，解决不确定具体对象类型的问题。其所操作的数据类型被指定为一个参数（type parameter）这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。 泛型类泛型类（generic cla">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://t7.baidu.com/it/u=1723468391,764687099&fm=193&f=GIF">
<meta property="article:published_time" content="2022-06-19T13:50:08.141Z">
<meta property="article:modified_time" content="2022-06-20T14:12:22.333Z">
<meta property="article:author" content="woaker">
<meta property="article:tag" content="程序员">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://t7.baidu.com/it/u=1723468391,764687099&fm=193&f=GIF"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/06/19/JavaHome/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/%E6%B3%9B%E5%9E%8B%E8%A7%A3%E6%9E%90/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '泛型解析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-06-20 22:12:22'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">134</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/List"><i class="fa-fw fas fa-list"></i><span> Study</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://t7.baidu.com/it/u=825057118,3516313570&amp;fm=193&amp;f=GIF')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">每天都不一样</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/List"><i class="fa-fw fas fa-list"></i><span> Study</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">泛型解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-06-19T13:50:08.141Z" title="发表于 2022-06-19 21:50:08">2022-06-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-06-20T14:12:22.333Z" title="更新于 2022-06-20 22:12:22">2022-06-20</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="泛型解析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>整理了Java泛型的相关知识，算是比较基础的，希望大家一起学习进步。<br><img src="https://user-gold-cdn.xitu.io/2020/1/18/16fb94807a022b0a?w=1111&h=458&f=png&s=67897"></p>
<h3 id="一、什么是Java泛型"><a href="#一、什么是Java泛型" class="headerlink" title="一、什么是Java泛型"></a>一、什么是Java泛型</h3><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性，其本质是参数化类型，解决不确定具体对象类型的问题。其所操作的数据类型被指定为一个参数（type parameter）这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。</p>
<h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p>泛型类（generic class) 就是具有<strong>一个或多个类型变量</strong>的类。一个泛型类的简单例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//常见的如T、E、K、V等形式的参数常用于表示泛型，编译时无法知道它们类型，实例化时需要指定。</span><br><span class="line">public class Pair &lt;K,V&gt;&#123;</span><br><span class="line">    private K first;</span><br><span class="line">    private  V second;</span><br><span class="line"></span><br><span class="line">    public Pair(K first, V second) &#123;</span><br><span class="line">        this.first = first;</span><br><span class="line">        this.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public K getFirst() &#123;</span><br><span class="line">        return first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setFirst(K first) &#123;</span><br><span class="line">        this.first = first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public V getSecond() &#123;</span><br><span class="line">        return second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSecond(V second) &#123;</span><br><span class="line">        this.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    // 此处K传入了Integer，V传入String类型</span><br><span class="line">        Pair&lt;Integer,String&gt; pairInteger = new Pair&lt;&gt;(1, &quot;第二&quot;);</span><br><span class="line">        System.out.println(&quot;泛型测试，first is &quot; + pairInteger.getFirst()</span><br><span class="line">                + &quot; ,second is &quot; + pairInteger.getSecond());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">泛型测试，first is 1 ,second is 第二</span><br></pre></td></tr></table></figure>

<h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><p>泛型也可以应用于接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Generator&lt;T&gt; &#123;</span><br><span class="line">    T next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现类去实现这个接口的时候，可以指定泛型T的具体类型。</p>
<p>指定具体类型为Integer的实现类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class NumberGenerator implements Generator&lt;Integer&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Integer next() &#123;</span><br><span class="line">        return new Random().nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指定具体类型为String的实现类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class StringGenerator implements Generator&lt;String&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public String next() &#123;</span><br><span class="line">        return &quot;测试泛型接口&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p>具有一个或多个类型变量的方法，称之为泛型方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class GenericMethods &#123;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; void f(T x)&#123;</span><br><span class="line">        System.out.println(x.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        GenericMethods gm = new GenericMethods();</span><br><span class="line">        gm.f(&quot;字符串&quot;);</span><br><span class="line">        gm.f(666);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.String</span><br><span class="line">java.lang.Integer</span><br></pre></td></tr></table></figure>
<h3 id="二、泛型的好处"><a href="#二、泛型的好处" class="headerlink" title="二、泛型的好处"></a>二、泛型的好处</h3><p>Java语言引入泛型的好处是<strong>安全简单</strong>。泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高代码的重用率。</p>
<p>我们先来看看一个只能持有单个对象的类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Holder1 &#123;</span><br><span class="line">    private Automobile a;</span><br><span class="line"></span><br><span class="line">    public Holder1(Automobile a) &#123;</span><br><span class="line">        this.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Automobile getA() &#123;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以发现，这个类的重用性不怎样。要使它持有其他类型的任何对象，在jdk1.5泛型之前，可以把类型设置为Object，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Holder2 &#123;</span><br><span class="line">    private Object a;</span><br><span class="line"></span><br><span class="line">    public Holder2(Object a) &#123;</span><br><span class="line">        this.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object getA() &#123;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setA(Object a) &#123;</span><br><span class="line">        this.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Holder2 holder2 = new Holder2(new Automobile());</span><br><span class="line">        //强制转换</span><br><span class="line">        Automobile automobile = (Automobile) holder2.getA();</span><br><span class="line">        holder2.setA(&quot;测试泛型&quot;);</span><br><span class="line">        String s = (String) holder2.getA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们引入泛型，实现功能那个跟Holder2类一致的Holder3，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Holder3&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private T a;</span><br><span class="line"></span><br><span class="line">    public T getA() &#123;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setA(T a) &#123;</span><br><span class="line">        this.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Holder3(T a) &#123;</span><br><span class="line">        this.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Holder3&lt;Automobile&gt; holder3 = new Holder3&lt;&gt;(new Automobile());</span><br><span class="line">        Automobile automobile = holder3.getA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因此，泛型的好处很明显了：</p>
<ul>
<li>不用强制转换，因此代码比较简洁；（简洁性）</li>
<li>代替Object来表示其他类型对象，与ClassCastException异常划清界限。（安全性）</li>
<li>泛型使代码可读性增强。（可读性）</li>
</ul>
<h3 id="三、泛型通配符"><a href="#三、泛型通配符" class="headerlink" title="三、泛型通配符"></a>三、泛型通配符</h3><p>我们定义泛型时，经常碰见T，E，K，V，？等通配符。本质上这些都是通配符，是编码时一种约定俗成的东西。当然，你换个A-Z中另一个字母表示没有关系，但是为了可读性，一般有以下定义：</p>
<ul>
<li>？ 表示不确定的 java 类型</li>
<li>T (type) 表示具体的一个java类型</li>
<li>K V (key value) 分别代表java键值中的Key Value</li>
<li>E (element) 代表Element</li>
</ul>
<p><strong>为什么需要引入通配符</strong>呢，我们先来看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class Fruit&#123;</span><br><span class="line">    public int getWeigth()&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//Apple是水果Fruit类的子类</span><br><span class="line">class Apple extends Fruit &#123;</span><br><span class="line">    public int getWeigth()&#123;</span><br><span class="line">        return 5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class GenericTest &#123;</span><br><span class="line">    //数组的传参</span><br><span class="line">    static int sumWeigth(Fruit[] fruits) &#123;</span><br><span class="line">        int weight = 0;</span><br><span class="line">        for (Fruit fruit : fruits) &#123;</span><br><span class="line">            weight += fruit.getWeigth();</span><br><span class="line">        &#125;</span><br><span class="line">        return weight;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static int sumWeight1(List&lt;? extends Fruit&gt; fruits) &#123;</span><br><span class="line">        int weight = 0;</span><br><span class="line">        for (Fruit fruit : fruits) &#123;</span><br><span class="line">            weight += fruit.getWeigth();</span><br><span class="line">        &#125;</span><br><span class="line">        return weight;</span><br><span class="line">    &#125;</span><br><span class="line">    static  int sumWeigth2(List&lt;Fruit&gt; fruits)&#123;</span><br><span class="line">        int weight = 0;</span><br><span class="line">        for (Fruit fruit : fruits) &#123;</span><br><span class="line">            weight += fruit.getWeigth();</span><br><span class="line">        &#125;</span><br><span class="line">        return weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Fruit[] fruits = new Apple[10];</span><br><span class="line">        sumWeigth(fruits);</span><br><span class="line">        List&lt;Apple&gt; apples = new ArrayList&lt;&gt;();</span><br><span class="line">        sumWeight1(apples);</span><br><span class="line">        //报错</span><br><span class="line">        sumWeigth2(apples);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以发现，Fruit[]与Apple[]是兼容的。<code>List&lt;Fruit&gt;</code>与<code>List&lt;Apple&gt;</code>不兼容的，集合List是不能协变的，会报错，而List<Fruit>与List&lt;?  extends Fruits&gt; 是OK的，这就是通配符的魅力所在。通配符通常分三类：</p>
<ul>
<li>无边界通配符，如List&lt;?&gt;</li>
<li>上边界限定通配符,如&lt;? extends E&gt;;</li>
<li>下边界通配符，如&lt;? super E&gt;;</li>
</ul>
<h4 id="无边界通配符"><a href="#无边界通配符" class="headerlink" title="?无边界通配符"></a>?无边界通配符</h4><p>无边界通配符，它的使用形式是一个单独的问号：List&lt;?&gt;，也就是没有任何限定。</p>
<p>看个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class GenericTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void printList(List&lt;?&gt; list) &#123;</span><br><span class="line">        for (Object object : list) &#123;</span><br><span class="line">            System.out.println(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;String&gt; list1 = new ArrayList&lt;&gt;();</span><br><span class="line">        list1.add(&quot;A&quot;);</span><br><span class="line">        list1.add(&quot;B&quot;);</span><br><span class="line">        List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();</span><br><span class="line">        list2.add(100);</span><br><span class="line">        list2.add(666);</span><br><span class="line">        //报错，List&lt;?&gt;不能添加任何类型</span><br><span class="line">        List&lt;?&gt; list3 = new ArrayList&lt;&gt;();</span><br><span class="line">        list3.add(666);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无界通配符(<?>)可以适配任何引用类型，看起来与原生类型等价，但与原生类型还是有区别，使用
**无界通配符则表明在使用泛型** 。同时，List<?> list不可以添加任何类型，因为并不知道实际是哪种类型。但是List list因为持有的是Object类型对象，所以可以add任何类型的对象。</p>
<h4 id="上边界限定通配符-lt-extends-E-gt"><a href="#上边界限定通配符-lt-extends-E-gt" class="headerlink" title="上边界限定通配符 &lt; ? extends E&gt;"></a>上边界限定通配符 &lt; ? extends E&gt;</h4><p>使用 &lt;? extends Fruit&gt; 形式的通配符，就是<strong>上边界限定通配符</strong>。 extends关键字表示这个泛型中的参数必须是 E 或者 E 的子类，请看demo：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class apple extends Fruit&#123;&#125;</span><br><span class="line">static int sumWeight1(List&lt;? extends Fruit&gt; fruits) &#123;</span><br><span class="line">    int weight = 0;</span><br><span class="line">    for (Fruit fruit : fruits) &#123;</span><br><span class="line">        weight += fruit.getWeigth();</span><br><span class="line">    &#125;</span><br><span class="line">    return weight;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Apple&gt; apples = new ArrayList&lt;&gt;();</span><br><span class="line">    sumWeight1(apples);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，以下这段代码是<strong>不可行</strong>的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static int sumWeight1(List&lt;? extends Fruit&gt; fruits)&#123;</span><br><span class="line">   //报错</span><br><span class="line">   fruits.add(new Fruit());</span><br><span class="line">   //报错</span><br><span class="line">   fruits.add(new Apple());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在<code>List&lt;Fruit&gt; </code>里只能添加Fruit类对象及其子类对象（如Apple对象，Oragne对象），在<code>List&lt;Apple&gt;</code>里只能添加Apple类和其子类对象。</li>
<li>我们知道<code>List&lt;Fruit&gt;、List&lt;Apple&gt;</code>等都是List&lt;？ extends Fruit&gt;的子类型。假设一开始传参是<code>List&lt;Fruit&gt; list</code>,两个添加没问题，那如果传来<code>List&lt;Apple&gt; list</code>，添加就失败了，编译器为了保护自己，直接禁用添加功能了。</li>
<li>实际上，不能往List&lt;? extends E&gt; 添加任意对象，除了null。</li>
</ul>
<h4 id="下边界限定通配符-lt-super-E-gt"><a href="#下边界限定通配符-lt-super-E-gt" class="headerlink" title="下边界限定通配符 &lt; ? super E&gt;"></a>下边界限定通配符 &lt; ? super E&gt;</h4><p>使用 &lt;? super E&gt; 形式的通配符，就是<strong>下边界限定通配符</strong>。 super关键字表示这个泛型中的参数必须是所指定的类型E，或者是此类型的父类型，直至 Object。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class GenericTest &#123;</span><br><span class="line"></span><br><span class="line">    private static &lt;T&gt; void test(List&lt;? super T&gt; dst, List&lt;T&gt; src)&#123;</span><br><span class="line">        for (T t : src) &#123;</span><br><span class="line">            dst.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Apple&gt; apples = new ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Fruit&gt; fruits = new ArrayList&lt;&gt;();</span><br><span class="line">        test(fruits, apples);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以发现，List&lt;? super E&gt;添加是没有问题的，因为子类是可以指向父类的，它添加并不像List&lt;? extends E&gt;会出现安全性问题，所以可行。</p>
<h3 id="四、泛型擦除"><a href="#四、泛型擦除" class="headerlink" title="四、泛型擦除"></a>四、泛型擦除</h3><h4 id="什么是类型擦除"><a href="#什么是类型擦除" class="headerlink" title="什么是类型擦除"></a>什么是类型擦除</h4><p>什么是Java<strong>泛型擦除</strong>呢？<br>先来看demo：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class c1 = new ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">Class c2 = new ArrayList&lt;String&gt;().getClass();</span><br><span class="line">System.out.println(c1 == c2);</span><br><span class="line">/* Output</span><br><span class="line">true</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><figcaption><span><Integer>``` 和```ArrayList <String>``` 很容易被认为是不同的类型。但是这里输出结果是true，这是因为Java泛型是使用擦除实现的，不管是``` ArrayList<Integer>()``` 还是``` new ArrayList<String>()```，在编译生成的字节码中都不包含泛型中的类型参数，即都擦除成了ArrayList，也就是被擦除成“原生类型”，这就是泛型擦除。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 类型擦除底层</span><br><span class="line">Java泛型在编译期完成，它是依赖编译器实现的。其实，编译器主要做了这些工作：</span><br><span class="line">- set()方法的类型检验</span><br><span class="line">- get()处的类型转换，编译器插入了一个checkcast语句，</span><br><span class="line"></span><br><span class="line">再看个例子：</span><br></pre></td></tr></table></figure>
<p>public class GenericTest<T> {</p>
<pre><code>private T t;

public T get() &#123;
    return t;
&#125;

public void set(T t) &#123;
    this.t = t;
&#125;

public static void main(String[] args) &#123;
    GenericTest&lt;String&gt; test = new GenericTest&lt;String&gt;();
    test.set(&quot;jay@huaxiao&quot;);
    String s = test.get();
    System.out.println(s);
&#125;
</code></pre>
<p>}<br>&#x2F;* Output<br>jay@huaxiao<br>*&#x2F;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">javap -c GenericTest.class反编译GenericTest类可得</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>public class generic.GenericTest<T> {<br>  public generic.GenericTest();<br>    Code:<br>       0: aload_0<br>       1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.”<init>“:()V<br>       4: return</p>
<p>  public T get();<br>    Code:<br>       0: aload_0<br>       1: getfield      #2                  &#x2F;&#x2F; Field t:Ljava&#x2F;lang&#x2F;Object;<br>       4: areturn</p>
<p>  public void set(T);<br>    Code:<br>       0: aload_0<br>       1: aload_1<br>       2: putfield      #2                  &#x2F;&#x2F; Field t:Ljava&#x2F;lang&#x2F;Object;<br>       5: return</p>
<p>  public static void main(java.lang.String[]);<br>    Code:<br>       0: new           #3                  &#x2F;&#x2F; class generic&#x2F;GenericTest<br>       3: dup<br>       4: invokespecial #4                  &#x2F;&#x2F; Method “<init>“:()V<br>       7: astore_1<br>       8: aload_1<br>       9: ldc           #5                  &#x2F;&#x2F; String jay@huaxiao<br>      11: invokevirtual #6                  &#x2F;&#x2F; Method set:(Ljava&#x2F;lang&#x2F;Object;)V<br>      14: aload_1<br>      15: invokevirtual #7                  &#x2F;&#x2F; Method get:()Ljava&#x2F;lang&#x2F;Object;<br>      18: checkcast     #8                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;String<br>      21: astore_2<br>      22: getstatic     #9                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;<br>      25: aload_2<br>      26: invokevirtual #10                 &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V<br>      29: return<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- 看第11，set进去的是原始类型Object（#6）；</span><br><span class="line">- 看第15，get方法获得也是Object类型（#7），说明类型被擦出了。</span><br><span class="line">- 再看第18，它做了一个checkcast操作，是一个String类型，强转。</span><br><span class="line"></span><br><span class="line">### 五、泛型的限制与局限</span><br><span class="line">使用Java泛型需要考虑以下一些约束与限制，其实几乎都跟泛型擦除有关。</span><br><span class="line">#### 不能用基本类型实例化类型化参数</span><br><span class="line">不能用类型参数代替基本类型。因此， 没有 ```Pair&lt;double&gt;```, 只 有``` Pair&lt;Double&gt;```。 当然, 其原因是类型擦除。擦除之后， Pair 类含有 Object 类型的域， 而 Object 不能存储 double值。</span><br><span class="line"></span><br><span class="line">#### 运行时类型查询只适用于原始类型</span><br><span class="line">如，getClass()方法等只返回原始类型，因为JVM根本就不知道泛型这回事，它只知道原始类型。</span><br></pre></td></tr></table></figure>
<p>if(a instanceof Pair<String>) &#x2F;&#x2F;ERROR,仅测试了a是否是任意类型的一个Pair，会看到编译器ERROR警告</p>
<p>if(a instanceof Pair<T>) &#x2F;&#x2F;ERROR</p>
<p>Pair<String> p &#x3D; (Pair<String>) a;&#x2F;&#x2F;WARNING,仅测试a是否是一个Pair</p>
<p>Pair<String> stringPair &#x3D; …;<br>Pair<Employee> employeePair &#x3D; …;<br>if(stringPair.getClass() &#x3D;&#x3D; employeePair.getClass())  &#x2F;&#x2F;会得到true，因为两次调用getClass都将返回Pair.class</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 不能创建参数化类型的数组</span><br><span class="line">不能实例化参数化类型的数组， 例如： </span><br></pre></td></tr></table></figure>
<p>Pair<String>[] table &#x3D; new Pair<String>[10]; &#x2F;&#x2F; Error</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 不能实例化类型变量</span><br><span class="line">不能使用像 new T(...)，newT[...] 或 T.class 这样的表达式中的类型变量。例如， 下面的``` Pair&lt;T&gt;``` 构造器就是非法的：</span><br></pre></td></tr></table></figure>
<p>public Pair() { first &#x3D; new T(); second &#x3D; new T(); } &#x2F;&#x2F; Error </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#### 使用泛型接口时，需要避免重复实现同一个接口</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>interface Swim<T> {}</p>
<p>class Duck implements Swim<Duck> {}</p>
<p>class UglyDuck extends Duck implements Swim<UglyDuck> {}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#### 可以消除对受查异常的检查</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>@SuppressWamings(“unchecked”)<br>public static &lt;T extends Throwable〉void throwAs(Throwable e) throws T { throw (T) e; }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#### 定义API返回报文时，尽量使用泛型；</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>public class Response<T> extends BaseResponse {<br>    private static final long serialVersionUID &#x3D; -xxx;</p>
<pre><code>private T data;

private String code;

public Response() &#123;
&#125;

public T getData() &#123;
    return this.data;
&#125;

public void setData(T data,String code ) &#123;
    this.data = data;
    this.code = code;
&#125;
</code></pre>
<p>}</p>
<pre><code>
### 六、Java泛型常见面试题
Java泛型常见几道面试题
- Java中的泛型是什么 ? 使用泛型的好处是什么?（第一，第二小节可答）
- Java的泛型是如何工作的 ? 什么是类型擦除 ? （第四小节可答）
- 什么是泛型中的限定通配符和非限定通配符 ? （第三小节可答）
- List&lt;? extends T&gt;和List &lt;? super T&gt;之间有什么区别 ?（第三小节可答）
- 你了解泛型通配符与上下界吗？（第三小节可答）

### 参考与感谢
- 《Java编程思想》
- 《Java核心技术》
-  [聊一聊-JAVA 泛型中的通配符 T，E，K，V，？](https://juejin.im/post/5d5789d26fb9a06ad0056bd9)
-  [Java泛型的局限和使用经验](https://www.jianshu.com/p/a58da9011f85)
-  [Java泛型之类型擦除](https://zhuanlan.zhihu.com/p/31741402)

### 个人公众号

![](https://user-gold-cdn.xitu.io/2019/7/28/16c381c89b127bbb?w=344&amp;h=344&amp;f=jpeg&amp;s=8943)

- 如果你是个爱学习的好孩子，可以关注我公众号，一起学习讨论。
- 如果你觉得本文有哪些不正确的地方，可以评论，也可以关注我公众号，私聊我，大家一起学习进步哈。



</code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">woaker</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/06/19/JavaHome/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/%E6%B3%9B%E5%9E%8B%E8%A7%A3%E6%9E%90/">http://example.com/2022/06/19/JavaHome/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/%E6%B3%9B%E5%9E%8B%E8%A7%A3%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">每天都不一样</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://t7.baidu.com/it/u=1723468391,764687099&amp;fm=193&amp;f=GIF" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/06/19/JavaHome/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E7%9C%8B%E5%93%AA%E4%BA%9B%E4%B9%A6/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E7%9C%8B%E5%93%AA%E4%BA%9B%E4%B9%A6/"><img class="prev-cover" src="https://t7.baidu.com/it/u=1723468391,764687099&amp;fm=193&amp;f=GIF" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java程序员需要看哪些书</div></div></a></div><div class="next-post pull-right"><a href="/2022/06/19/JavaHome/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/%E8%A7%A6%E5%8F%91%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%85%AD%E5%A4%A7%E6%97%B6%E6%9C%BA/"><img class="next-cover" src="https://t7.baidu.com/it/u=1723468391,764687099&amp;fm=193&amp;f=GIF" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">触发类加载的六大时机</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">woaker</div><div class="author-info__description">不积跬步无以至千里</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">134</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/woaker"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFJava%E6%B3%9B%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">一、什么是Java泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text">泛型类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.2.</span> <span class="toc-text">泛型接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">泛型方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">3.</span> <span class="toc-text">二、泛型的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">4.</span> <span class="toc-text">三、泛型通配符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E8%BE%B9%E7%95%8C%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">4.1.</span> <span class="toc-text">?无边界通配符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E8%BE%B9%E7%95%8C%E9%99%90%E5%AE%9A%E9%80%9A%E9%85%8D%E7%AC%A6-lt-extends-E-gt"><span class="toc-number">4.2.</span> <span class="toc-text">上边界限定通配符 &lt; ? extends E&gt;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E8%BE%B9%E7%95%8C%E9%99%90%E5%AE%9A%E9%80%9A%E9%85%8D%E7%AC%A6-lt-super-E-gt"><span class="toc-number">4.3.</span> <span class="toc-text">下边界限定通配符 &lt; ? super E&gt;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="toc-number">5.</span> <span class="toc-text">四、泛型擦除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="toc-number">5.1.</span> <span class="toc-text">什么是类型擦除</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/06/19/JavaHome/%E7%BC%93%E5%AD%98Redis%E6%80%BB%E7%BB%93/%E4%B8%83%E7%A7%8D%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" title="七种方案对比分布式锁"><img src="/image/8.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="七种方案对比分布式锁"/></a><div class="content"><a class="title" href="/2022/06/19/JavaHome/%E7%BC%93%E5%AD%98Redis%E6%80%BB%E7%BB%93/%E4%B8%83%E7%A7%8D%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" title="七种方案对比分布式锁">七种方案对比分布式锁</a><time datetime="2022-06-19T13:50:08.178Z" title="发表于 2022-06-19 21:50:08">2022-06-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/19/JavaHome/%E7%BC%93%E5%AD%98Redis%E6%80%BB%E7%BB%93/%E4%BD%BF%E7%94%A8Redis%E7%9A%8421%E4%B8%AA%E6%B3%A8%E6%84%8F%E7%82%B9/" title="学习Redis相关知识"><img src="/image/7.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="学习Redis相关知识"/></a><div class="content"><a class="title" href="/2022/06/19/JavaHome/%E7%BC%93%E5%AD%98Redis%E6%80%BB%E7%BB%93/%E4%BD%BF%E7%94%A8Redis%E7%9A%8421%E4%B8%AA%E6%B3%A8%E6%84%8F%E7%82%B9/" title="学习Redis相关知识">学习Redis相关知识</a><time datetime="2022-06-19T13:50:08.178Z" title="发表于 2022-06-19 21:50:08">2022-06-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/19/JavaHome/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7%E7%AF%87/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80%EF%BC%9AGit%20%E5%91%BD%E4%BB%A4%E5%85%A8%E6%96%B9%E4%BD%8D%E5%AD%A6%E4%B9%A0/" title="程序员必备基础：Git 命令全方位学习"><img src="/image/5.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="程序员必备基础：Git 命令全方位学习"/></a><div class="content"><a class="title" href="/2022/06/19/JavaHome/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7%E7%AF%87/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80%EF%BC%9AGit%20%E5%91%BD%E4%BB%A4%E5%85%A8%E6%96%B9%E4%BD%8D%E5%AD%A6%E4%B9%A0/" title="程序员必备基础：Git 命令全方位学习">程序员必备基础：Git 命令全方位学习</a><time datetime="2022-06-19T13:50:08.178Z" title="发表于 2022-06-19 21:50:08">2022-06-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/19/JavaHome/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/" title="数据库连接池内存泄漏问题分析"><img src="https://t7.baidu.com/it/u=1723468391,764687099&amp;fm=193&amp;f=GIF" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库连接池内存泄漏问题分析"/></a><div class="content"><a class="title" href="/2022/06/19/JavaHome/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/" title="数据库连接池内存泄漏问题分析">数据库连接池内存泄漏问题分析</a><time datetime="2022-06-19T13:50:08.177Z" title="发表于 2022-06-19 21:50:08">2022-06-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/19/JavaHome/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%90%E7%94%A8%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98/" title="线程池运用不当导致的问题"><img src="/image/5.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="线程池运用不当导致的问题"/></a><div class="content"><a class="title" href="/2022/06/19/JavaHome/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%90%E7%94%A8%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98/" title="线程池运用不当导致的问题">线程池运用不当导致的问题</a><time datetime="2022-06-19T13:50:08.177Z" title="发表于 2022-06-19 21:50:08">2022-06-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By woaker</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
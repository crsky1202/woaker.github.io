<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>1-80题答案解析 | 每天都不一样</title><meta name="keywords" content="程序员"><meta name="author" content="woaker"><meta name="copyright" content="woaker"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言前几天，在茫茫的互联网海洋中寻寻觅觅，我收藏了800道Java基础经典面试题，有小伙伴私聊我要答案。所以感觉没有答案的面试题是没有灵魂的，于是今天先整理基础篇的前80道答案出来~ 所有的Java面试题已经上传github，答案也上传了一部分~  https:&#x2F;&#x2F;github.com&#x2F;whx123&#x2F;JavaHome&#x2F;tree&#x2F;master&#x2F;Java%E9%9D%A2%E8%AF%95%E9%A2">
<meta property="og:type" content="article">
<meta property="og:title" content="1-80题答案解析">
<meta property="og:url" content="http://example.com/2022/06/19/JavaHome/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E7%BB%93%E5%8F%B7/java%20%E5%9F%BA%E7%A1%80/1-80%E9%A2%98%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="每天都不一样">
<meta property="og:description" content="前言前几天，在茫茫的互联网海洋中寻寻觅觅，我收藏了800道Java基础经典面试题，有小伙伴私聊我要答案。所以感觉没有答案的面试题是没有灵魂的，于是今天先整理基础篇的前80道答案出来~ 所有的Java面试题已经上传github，答案也上传了一部分~  https:&#x2F;&#x2F;github.com&#x2F;whx123&#x2F;JavaHome&#x2F;tree&#x2F;master&#x2F;Java%E9%9D%A2%E8%AF%95%E9%A2">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/image/15.jpeg">
<meta property="article:published_time" content="2022-06-19T13:50:08.147Z">
<meta property="article:modified_time" content="2022-06-20T16:24:05.559Z">
<meta property="article:author" content="woaker">
<meta property="article:tag" content="程序员">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/image/15.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/06/19/JavaHome/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E7%BB%93%E5%8F%B7/java%20%E5%9F%BA%E7%A1%80/1-80%E9%A2%98%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '1-80题答案解析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-06-21 00:24:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">194</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/List"><i class="fa-fw fas fa-list"></i><span> Study</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/image/15.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">每天都不一样</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/List"><i class="fa-fw fas fa-list"></i><span> Study</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">1-80题答案解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-06-19T13:50:08.147Z" title="发表于 2022-06-19 21:50:08">2022-06-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-06-20T16:24:05.559Z" title="更新于 2022-06-21 00:24:05">2022-06-21</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="1-80题答案解析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几天，在茫茫的互联网海洋中寻寻觅觅，我收藏了800道Java基础经典面试题，有小伙伴私聊我要答案。所以感觉没有答案的面试题是没有灵魂的，于是今天先整理基础篇的前80道答案出来~</p>
<p>所有的Java面试题已经上传github，答案也上传了一部分~</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/whx123/JavaHome/tree/master/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E7%BB%93%E5%8F%B7">https://github.com/whx123/JavaHome/tree/master/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E7%BB%93%E5%8F%B7</a></p>
</blockquote>
<h2 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h2><h3 id="1-equals与-x3D-x3D-的区别"><a href="#1-equals与-x3D-x3D-的区别" class="headerlink" title="1. equals与&#x3D;&#x3D;的区别"></a>1. equals与&#x3D;&#x3D;的区别</h3><p><img src="https://user-gold-cdn.xitu.io/2020/5/10/171ff375ad2f6e94?w=720&h=404&f=png&s=237039"><br><strong>&#x3D;&#x3D;</strong></p>
<ul>
<li>如果是基本类型，&#x3D;&#x3D;表示判断它们值是否相等；</li>
<li>如果是引用对象，&#x3D;&#x3D;表示判断两个对象指向的内存地址是否相同。</li>
</ul>
<p><strong>equals</strong></p>
<ul>
<li>如果是字符串，表示判断字符串内容是否相同；</li>
<li>如果是object对象的方法，比较的也是引用的内存地址值；</li>
<li>如果自己的类重写equals方法，可以自定义两个对象是否相等。</li>
</ul>
<h3 id="2-final-finally-finalize-的区别"><a href="#2-final-finally-finalize-的区别" class="headerlink" title="2. final, finally, finalize 的区别"></a>2. final, finally, finalize 的区别</h3><ul>
<li>final 用于修饰属性,方法和类, 分别表示属性不能被重新赋值, 方法不可被覆盖, 类不可被继承.</li>
<li>finally 是异常处理语句结构的一部分，一般以ty-catch-finally出现，finally代码块表示总是被执行.</li>
<li>finalize 是Object类的一个方法，该方法一般由垃圾回收器来调用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()方法，回收垃圾，JVM并不保证此方法总被调用.</li>
</ul>
<h3 id="3-重载和重写的区别"><a href="#3-重载和重写的区别" class="headerlink" title="3. 重载和重写的区别"></a>3. 重载和重写的区别</h3><ul>
<li>重写必须继承，重载不用。</li>
<li>重载表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）</li>
<li>重写表示子类中的方法与父类中的某个方法的名称和参数完全相同啦，通过子类实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这是面向对象编程的多态性的一种表现。</li>
<li>重写的方法修饰符大于等于父类的方法，即访问权限只能比父类的更大，不能更小，而重载和修饰符无关。</li>
<li>重写覆盖的方法中，只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常，因为不能坑爹啊哈哈~</li>
</ul>
<h3 id="4-两个对象的hashCode-相同，则-equals-是否也一定为-true？"><a href="#4-两个对象的hashCode-相同，则-equals-是否也一定为-true？" class="headerlink" title="4. 两个对象的hashCode()相同，则 equals()是否也一定为 true？"></a>4. 两个对象的hashCode()相同，则 equals()是否也一定为 true？</h3><p>两个对象equals相等，则它们的hashcode必须相等，如果两个对象的hashCode()相同，则equals()不一定为true。</p>
<p><strong>hashCode 的常规协定：</strong></p>
<ul>
<li>在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。</li>
<li>两个对象的equals()相等，那么对这两个对象中的每个对象调用 hashCode 方法都必须生成相同的整数结果。</li>
<li>两个对象的equals()不相等，那么对这两个对象中的任一对象上调用 hashCode 方法不要求一定生成不同的整数结果。但是，为不相等的对象生成不同整数结果可以提高哈希表的性能。</li>
</ul>
<h3 id="5-抽象类和接口有什么区别"><a href="#5-抽象类和接口有什么区别" class="headerlink" title="5. 抽象类和接口有什么区别"></a>5. 抽象类和接口有什么区别</h3><ul>
<li>抽象类要被子类继承，接口要被子类实现。</li>
<li>抽象类可以有构造方法，接口中不能有构造方法。</li>
<li>抽象类中可以有普通成员变量，接口中没有普通成员变量，它的变量只能是公共的静态的常量</li>
<li>一个类可以实现多个接口，但是只能继承一个父类，这个父类可以是抽象类。</li>
<li>接口只能做方法声明，抽象类中可以作方法声明，也可以做方法实现。</li>
<li>抽象级别（从高到低）：接口&gt;抽象类&gt;实现类。</li>
<li>抽象类主要是用来抽象类别，接口主要是用来抽象方法功能。</li>
<li>抽象类的关键字是abstract，接口的关键字是interface</li>
</ul>
<h3 id="6-BIO、NIO、AIO-有什么区别？"><a href="#6-BIO、NIO、AIO-有什么区别？" class="headerlink" title="6. BIO、NIO、AIO 有什么区别？"></a>6. BIO、NIO、AIO 有什么区别？</h3><p>这个答案来自互联网哈，个人觉得是最好理解的~</p>
<blockquote>
<ul>
<li>BIO：线程发起 IO 请求，不管内核是否准备好 IO 操作，从发起请求起，线程一直阻塞，直到操作完成。</li>
<li>NIO：线程发起 IO 请求，立即返回；内核在做好 IO 操作的准备之后，通过调用注册的回调函数通知线程做 IO 操作，线程开始阻塞，直到操作完成。</li>
<li>AIO：线程发起 IO 请求，立即返回；内存做好 IO 操作的准备之后，做 IO 操作，直到操作完成或者失败，通过调用注册的回调函数通知线程做 IO 操作完成或者失败。</li>
</ul>
</blockquote>
<p>BIO 是一个连接一个线程。,NIO 是一个请求一个线程。,AIO 是一个有效请求一个线程。</p>
<blockquote>
<ul>
<li>BIO：同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。</li>
<li>NIO：同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I&#x2F;O请求时才启动一个线程进行处理。</li>
<li>AIO：异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的 IO 请求都是由 OS 先完成了再通知服务器应用去启动线程进行处理。</li>
</ul>
</blockquote>
<h3 id="7-String，Stringbuffer，StringBuilder的区别"><a href="#7-String，Stringbuffer，StringBuilder的区别" class="headerlink" title="7. String，Stringbuffer，StringBuilder的区别"></a>7. String，Stringbuffer，StringBuilder的区别</h3><p><strong>String：</strong></p>
<ul>
<li>String类是一个不可变的类，一旦创建就不可以修改。</li>
<li>String是final类，不能被继承</li>
<li>String实现了equals()方法和hashCode()方法</li>
</ul>
<p><strong>StringBuffer：</strong></p>
<ul>
<li>继承自AbstractStringBuilder，是可变类。</li>
<li>StringBuffer是线程安全的</li>
<li>可以通过append方法动态构造数据。</li>
</ul>
<p><strong>StringBuilder：</strong></p>
<ul>
<li>继承自AbstractStringBuilder，是可变类。</li>
<li>StringBuilder是非线性安全的。</li>
<li>执行效率比StringBuffer高。</li>
</ul>
<h3 id="8-JAVA中的几种基本数据类型是什么，各自占用多少字节呢"><a href="#8-JAVA中的几种基本数据类型是什么，各自占用多少字节呢" class="headerlink" title="8. JAVA中的几种基本数据类型是什么，各自占用多少字节呢"></a>8. JAVA中的几种基本数据类型是什么，各自占用多少字节呢</h3><table>
<thead>
<tr>
<th>基本类型</th>
<th>位数</th>
<th>字节</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>32</td>
<td>4</td>
</tr>
<tr>
<td>short</td>
<td>16</td>
<td>2</td>
</tr>
<tr>
<td>long</td>
<td>64</td>
<td>8</td>
</tr>
<tr>
<td>byte</td>
<td>8</td>
<td>1</td>
</tr>
<tr>
<td>char</td>
<td>16</td>
<td>2</td>
</tr>
<tr>
<td>float</td>
<td>32</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td>64</td>
<td>8</td>
</tr>
<tr>
<td>boolean</td>
<td>？</td>
<td>？</td>
</tr>
</tbody></table>
<p>对于boolean，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1位，但是实际中会考虑计算机高效存储因素</p>
<p>感兴趣的小伙伴，可以去看<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html">官网</a></p>
<h3 id="9-Comparator与Comparable有什么区别？"><a href="#9-Comparator与Comparable有什么区别？" class="headerlink" title="9. Comparator与Comparable有什么区别？"></a>9. Comparator与Comparable有什么区别？</h3><p>在牛客网看到这道题的答案，觉得写的最好~</p>
<blockquote>
<p>链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/99f7d1f4f8374e419a6d6924d35d9530">https://www.nowcoder.com/questionTerminal/99f7d1f4f8374e419a6d6924d35d9530</a><br>来源：牛客网</p>
<ul>
<li>Comparable &amp; Comparator 都是用来实现集合中元素的比较、排序的，只是 Comparable 是在集合内部定义的方法实现的排序，Comparator 是在集合外部实现的排序，所以，如想实现排序，就需要在集合外定义 Comparator 接口的方法或在集合内实现 Comparable 接口的方法。</li>
<li>Comparator位于包java.util下，而Comparable位于包 java.lang下。</li>
<li>Comparable 是一个对象本身就已经支持自比较所需要实现的接口（如 String、Integer 自己就可以完成比较大小操作，已经实现了Comparable接口） 自定义的类要在加入list容器中后能够排序，可以实现Comparable接口，在用Collections类的sort方法排序时，如果不指定Comparator，那么就以自然顺序排序， 这里的自然顺序就是实现Comparable接口设定的排序方式。</li>
<li>而 Comparator 是一个专用的比较器，当这个对象不支持自比较或者自比较函数不能满足你的要求时，你可以写一个比较器来完成两个对象之间大小的比较。 </li>
<li>可以说一个是自已完成比较，一个是外部程序实现比较的差别而已。 用 Comparator 是策略模式（strategy design pattern），就是不改变对象自身，而用一个策略对象（strategy object）来改变它的行为。 比如：你想对整数采用绝对值大小来排序，Integer 是不符合要求的，你不需要去修改 Integer 类（实际上你也不能这么做）去改变它的排序行为，只要使用一个实现了 Comparator 接口的对象来实现控制它的排序就行了。</li>
</ul>
</blockquote>
<h3 id="10-String类能被继承吗，为什么。"><a href="#10-String类能被继承吗，为什么。" class="headerlink" title="10. String类能被继承吗，为什么。"></a>10. String类能被继承吗，为什么。</h3><p>首先，String是一个final修饰的类，final修饰的类不可以被继承。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br></pre></td></tr></table></figure>
<p><strong>String类为什么不能被继承呢？</strong></p>
<p>有两个原因：</p>
<ul>
<li>效率性，String 类作为最常用的类之一，禁止被继承和重写，可以提高效率。</li>
<li>安全性，String 类中有很多调用底层的本地方法，调用了操作系统的 API，如果方法可以重写，可能被植入恶意代码，破坏程序。</li>
</ul>
<h3 id="11-说说Java中多态的实现原理"><a href="#11-说说Java中多态的实现原理" class="headerlink" title="11. 说说Java中多态的实现原理"></a>11. 说说Java中多态的实现原理</h3><ul>
<li>多态机制包括静态多态（编译时多态）和动态多态（运行时多态）</li>
<li>静态多态比如说重载，动态多态一般指在运行时才能确定调用哪个方法。</li>
<li>我们通常所说的多态一般指运行时多态，也就是编译时不确定究竟调用哪个具体方法，一直等到运行时才能确定。</li>
<li>多态实现方式：子类继承父类（extends）和类实现接口（implements）</li>
<li>多态核心之处就在于对父类方法的改写或对接口方法的实现，以取得在运行时不同的执行效果。</li>
<li>Java 里对象方法的调用是依靠类信息里的方法表实现的，对象方法引用调用和接口方法引用调用的大致思想是一样的。当调用对象的某个方法时，JVM查找该对象类的方法表以确定该方法的直接引用地址，有了地址后才真正调用该方法。</li>
</ul>
<p>举个例子吧，假设有个Fruit父类，一个taste味道方法，两个子类Apple和Pear，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">abstract class Fruit &#123;</span><br><span class="line">    abstract String taste() ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Apple extends Fruit &#123;</span><br><span class="line">    @Override</span><br><span class="line">    String taste() &#123;</span><br><span class="line">        return &quot;酸酸的&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Pear extends Fruit &#123;</span><br><span class="line">    @Override</span><br><span class="line">    String taste() &#123;</span><br><span class="line">        return &quot;甜甜的&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Fruit f = new Apple();</span><br><span class="line">        System.out.println(f.taste());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行，当调用对象Fruit f的方法taste时，JVM查找Fruit对象类的方法表以确定taste方法的直接引用地址，到底来自Apple还是Pear，确定后才真正调用对应子类的taste方法，</p>
<h3 id="12-Java泛型和类型擦除"><a href="#12-Java泛型和类型擦除" class="headerlink" title="12. Java泛型和类型擦除"></a>12. Java泛型和类型擦除</h3><p>这个面试题，可以看我这篇文章哈~</p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5e1954c0f265da3e1e0568de">Java程序员必备基础：泛型解析</a></p>
<h3 id="13-int和Integer-有什么区别，还有Integer缓存的实现"><a href="#13-int和Integer-有什么区别，还有Integer缓存的实现" class="headerlink" title="13. int和Integer 有什么区别，还有Integer缓存的实现"></a>13. int和Integer 有什么区别，还有Integer缓存的实现</h3><p>这里考察3个知识点吧：</p>
<ul>
<li>int 是基本数据类型，interger 是 int 的封装类</li>
<li>int 默认值为 0 ，而interger 默认值为 null， Interger使用需要判空处理</li>
<li>Integer的缓存机制：为了节省内存和提高性能，Integer类在内部通过使用相同的对象引用实现缓存和重用，Integer类默认在-128 ~ 127 之间，可以通过 -XX:AutoBoxCacheMax进行修改，且这种机制仅在自动装箱的时候有用，在使用构造器创建Integer对象时无用。</li>
</ul>
<p>看个Integer的缓存的例子，加深一下印象哈：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Integer a = 10;</span><br><span class="line">Integer b = 10;</span><br><span class="line"></span><br><span class="line">Integer c = 129;</span><br><span class="line">Integer d = 129;</span><br><span class="line">System.out.println(a == b);</span><br><span class="line">System.out.println(c == d);</span><br><span class="line">输出结果：</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<h3 id="14-说说反射的用途及实现原理，Java获取反射的三种方法"><a href="#14-说说反射的用途及实现原理，Java获取反射的三种方法" class="headerlink" title="14. 说说反射的用途及实现原理，Java获取反射的三种方法"></a>14. 说说反射的用途及实现原理，Java获取反射的三种方法</h3><p>这道面试题，看我这篇文章哈：<a target="_blank" rel="noopener" href="https://juejin.im/post/5de3242e6fb9a071886675d7">谈谈Java反射：从入门到实践，再到原理</a></p>
<p>Java获取反射的<strong>三种方法</strong>：</p>
<ul>
<li>第一种，使用 Class.forName 静态方法。</li>
<li>第二种，使用类的.class 方法</li>
<li>第三种，使用实例对象的 getClass() 方法。</li>
</ul>
<h3 id="15-面向对象的特征"><a href="#15-面向对象的特征" class="headerlink" title="15. 面向对象的特征"></a>15. 面向对象的特征</h3><p>面向对象的三大特征：</p>
<ul>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ul>
<h3 id="16-amp-和-amp-amp-的区别"><a href="#16-amp-和-amp-amp-的区别" class="headerlink" title="16. &amp;和&amp;&amp;的区别"></a>16. &amp;和&amp;&amp;的区别</h3><ul>
<li>按位与, a&amp;b 表示把a和b都转换成二进制数，再进行与的运算；</li>
<li>&amp;和&amp;&amp;都是逻辑运算符号，&amp;&amp;又叫短路运算符</li>
<li>逻辑与，a&amp;&amp; b ，a&amp;b 都表示当且仅当两个操作数均为 true时，其结果才为 true，否则为false。</li>
<li>逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true，整个表达式的值才是true。但是，&amp;&amp;之所以称为短路运算，是因为如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。</li>
</ul>
<h3 id="17-Java中IO流分为几种"><a href="#17-Java中IO流分为几种" class="headerlink" title="17. Java中IO流分为几种?"></a>17. Java中IO流分为几种?</h3><ul>
<li>Java中的流分为两种：一种是字节流，另一种是字符流。</li>
<li>IO流分别由四个抽象类来表示（两输入两输出）:InputStream，OutputStream，Reader，Writer。</li>
</ul>
<h3 id="18-讲讲类的实例化顺序，比如父类静态数据，构造函数，子类静态数据，构造函数。"><a href="#18-讲讲类的实例化顺序，比如父类静态数据，构造函数，子类静态数据，构造函数。" class="headerlink" title="18. 讲讲类的实例化顺序，比如父类静态数据，构造函数，子类静态数据，构造函数。"></a>18. 讲讲类的实例化顺序，比如父类静态数据，构造函数，子类静态数据，构造函数。</h3><p>直接看个例子吧：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Parent &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;父类非静态代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;父类静态块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public Parent() &#123;</span><br><span class="line">        System.out.println(&quot;父类构造器&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Son extends Parent &#123;</span><br><span class="line">    public Son() &#123;</span><br><span class="line">        System.out.println(&quot;子类构造器&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;子类静态代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;子类非静态代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Son son = new Son();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">父类静态块</span><br><span class="line">子类静态代码块</span><br><span class="line">父类非静态代码块</span><br><span class="line">父类构造器</span><br><span class="line">子类非静态代码块</span><br><span class="line">子类构造器</span><br></pre></td></tr></table></figure>

<p>所以，<strong>类实例化顺序为：</strong><br>父类静态代码块&#x2F;静态域-&gt;子类静态代码块&#x2F;静态域 -&gt; 父类非静态代码块 -&gt; 父类构造器 -&gt; 子类非静态代码块 -&gt; 子类构造器</p>
<h3 id="19-Java创建对象有几种方式"><a href="#19-Java创建对象有几种方式" class="headerlink" title="19. Java创建对象有几种方式"></a>19. Java创建对象有几种方式</h3><p>Java创建对象有5种方式</p>
<ul>
<li>用new语句创建对象。</li>
<li>使用反射，使用Class.newInstance()创建对象&#x2F;调用类对象的构造方法——Constructor</li>
<li>调用对象的clone()方法。</li>
<li>运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法.</li>
<li>使用Unsafe</li>
</ul>
<h3 id="20-如何将GB2312编码的字符串转换为ISO-8859-1编码的字符串呢？"><a href="#20-如何将GB2312编码的字符串转换为ISO-8859-1编码的字符串呢？" class="headerlink" title="20. 如何将GB2312编码的字符串转换为ISO-8859-1编码的字符串呢？"></a>20. 如何将GB2312编码的字符串转换为ISO-8859-1编码的字符串呢？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) throws UnsupportedEncodingException &#123;</span><br><span class="line">        String str = &quot;捡田螺的小男孩&quot;;</span><br><span class="line">        String strIso = new String(str.getBytes(&quot;GB2312&quot;), &quot;ISO-8859-1&quot;);</span><br><span class="line">        System.out.println(strIso);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="21-守护线程是什么？用什么方法实现守护线程"><a href="#21-守护线程是什么？用什么方法实现守护线程" class="headerlink" title="21. 守护线程是什么？用什么方法实现守护线程"></a>21. 守护线程是什么？用什么方法实现守护线程</h3><ul>
<li>守护线程是运行在后台的一种特殊进程。</li>
<li>它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。</li>
<li>在 Java 中垃圾回收线程就是特殊的守护线程。</li>
</ul>
<h3 id="22-notify-和-notifyAll-有什么区别？"><a href="#22-notify-和-notifyAll-有什么区别？" class="headerlink" title="22. notify()和 notifyAll()有什么区别？"></a>22. notify()和 notifyAll()有什么区别？</h3><ul>
<li>notify是唤醒一个处于该对象wait的线程，而notifyAll是唤醒所有处于该对象wait的线程。</li>
<li>但是唤醒不等于就能执行了，需要得到锁对象才能有权利继续执行，而锁只有一把，所以多个线程被唤醒时需要争取该锁。</li>
</ul>
<h3 id="23-Java语言是如何处理异常的，关键字throws、throw、try、catch、finally怎么使用？"><a href="#23-Java语言是如何处理异常的，关键字throws、throw、try、catch、finally怎么使用？" class="headerlink" title="23. Java语言是如何处理异常的，关键字throws、throw、try、catch、finally怎么使用？"></a>23. Java语言是如何处理异常的，关键字throws、throw、try、catch、finally怎么使用？</h3><p>这道面试题，可以看我这篇文章哈：<a target="_blank" rel="noopener" href="https://juejin.im/post/5dc68c0f51882528957fadb3">Java程序员必备：异常的十个关键知识点</a></p>
<h3 id="24-谈谈Java的异常层次结构"><a href="#24-谈谈Java的异常层次结构" class="headerlink" title="24. 谈谈Java的异常层次结构"></a>24. 谈谈Java的异常层次结构</h3><p><img src="https://user-gold-cdn.xitu.io/2020/5/17/17221f084e60767b?w=1280&h=890&f=png&s=352606"></p>
<p>从前从前，有位老人，他的名字叫<strong>Throwable</strong>，他生了两个儿子，大儿子叫<strong>Error</strong>,二儿子叫<strong>Exception</strong>。</p>
<p><strong>Error</strong></p>
<p>表示编译时或者系统错误，如虚拟机相关的错误，OutOfMemoryError等，error是无法处理的。</p>
<p><strong>Exception</strong></p>
<p>代码异常，Java程序员关心的基类型通常是Exception。它能被程序本身可以处理，这也是它跟Error的区别。</p>
<p>它可以分为RuntimeException（运行时异常）和CheckedException（可检查的异常）。</p>
<p><strong>常见的RuntimeException异常：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- NullPointerException 空指针异常</span><br><span class="line">- ArithmeticException 出现异常的运算条件时，抛出此异常</span><br><span class="line">- IndexOutOfBoundsException 数组索引越界异常</span><br><span class="line">- ClassNotFoundException 找不到类异常</span><br><span class="line">- IllegalArgumentException(非法参数异常)</span><br></pre></td></tr></table></figure>

<p><strong>常见的 Checked Exception 异常：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- IOException (操作输入流和输出流时可能出现的异常)</span><br><span class="line">- ClassCastException(类型转换异常类)</span><br></pre></td></tr></table></figure>
<ul>
<li>Checked Exception就是编译器要求你必须处置的异常。</li>
<li>与之相反的是，Unchecked Exceptions，它指编译器不要求强制处置的异常，它包括Error和RuntimeException 以及他们的子类。</li>
</ul>
<h3 id="25-静态内部类与非静态内部类有什么区别"><a href="#25-静态内部类与非静态内部类有什么区别" class="headerlink" title="25. 静态内部类与非静态内部类有什么区别"></a>25. 静态内部类与非静态内部类有什么区别</h3><p>这道面试题，可以看我这篇文章哈：<a target="_blank" rel="noopener" href="https://juejin.im/post/5e105e1ef265da5d61695a45">Java程序员必备基础：内部类解析</a></p>
<ul>
<li>静态内部类可以有静态成员(方法，属性)，而非静态内部类则不能有静态成员(方法，属性)。</li>
<li>静态内部类只能够访问外部类的静态成员和静态方法,而非静态内部类则可以访问外部类的所有成员(方法，属性)。</li>
<li>实例化静态内部类与非静态内部类的方式不同</li>
<li>调用内部静态类的方法或静态变量,可以通过类名直接调用</li>
</ul>
<h3 id="26-String-s与new-String与有什么区别"><a href="#26-String-s与new-String与有什么区别" class="headerlink" title="26. String s与new String与有什么区别"></a>26. String s与new String与有什么区别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str =&quot;whx&quot;;</span><br><span class="line">String newStr =new String (&quot;whx&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>String str &#x3D;”whx”</strong></p>
<p>先在常量池中查找有没有”whx” 这个对象,如果有，就让str指向那个”whx”.如果没有，在常量池中新建一个“whx”对象，并让str指向在常量池中新建的对象”whx”。</p>
<p><strong>String newStr &#x3D;new String (“whx”);</strong></p>
<p>是在堆中建立的对象”whx” ,在栈中创建堆中”whx” 对象的内存地址。</p>
<p>如图所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/1/30/16ff695269a49781?w=917&h=545&f=png&s=56724"></p>
<p>网上这篇文章讲的挺好的：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/fullstack/article/details/23885879">String和New String()的区别</a></p>
<h3 id="27-反射中，Class-forName和ClassLoader的区别"><a href="#27-反射中，Class-forName和ClassLoader的区别" class="headerlink" title="27. 反射中，Class.forName和ClassLoader的区别"></a>27. 反射中，Class.forName和ClassLoader的区别</h3><p>Class.forName和ClassLoader都可以对类进行加载。它们区别在哪里呢？<br><strong>ClassLoader</strong>负责加载 Java 类的字节代码到 Java 虚拟机中。Class.forName其实是调用了ClassLoader，如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/1/31/16ffbda909fc7bee?w=1163&h=263&f=png&s=38067"><br>这里面，forName0的第二个参数为true，表示对加载的类进行初始化化。其实还可以调用<code>Class&lt;?&gt; forName(String name, boolean initialize,     ClassLoader loader)</code>方法实现一样的功能，它的源码如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/1/31/16ffbdf82a973dd0?w=1080&h=757&f=png&s=120576"></p>
<p>所以，Class.forName和ClassLoader的区别，就是在类加载的时候，class.forName有参数控制是否对类进行初始化。</p>
<h3 id="28-JDK动态代理与cglib实现的区别"><a href="#28-JDK动态代理与cglib实现的区别" class="headerlink" title="28. JDK动态代理与cglib实现的区别"></a>28. JDK动态代理与cglib实现的区别</h3><ul>
<li>java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。</li>
<li>cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。</li>
<li>JDK动态代理只能对实现了接口的类生成代理，而不能针对类</li>
<li>cglib是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法。因为是继承，所以该类或方法最好不要声明成final</li>
</ul>
<p>网上这篇文章写得不错，<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_23000805/article/details/89573804">描述Java动态代理的几种实现方式，分别说出相应的优缺点</a></p>
<h3 id="29-error和exception的区别，CheckedException，RuntimeException的区别。"><a href="#29-error和exception的区别，CheckedException，RuntimeException的区别。" class="headerlink" title="29. error和exception的区别，CheckedException，RuntimeException的区别。"></a>29. error和exception的区别，CheckedException，RuntimeException的区别。</h3><p><img src="https://user-gold-cdn.xitu.io/2020/2/1/16ffc91a38aadaa0?w=1370&h=953&f=png&s=122496"></p>
<p><strong>Error:</strong> 表示编译时或者系统错误，如虚拟机相关的错误，OutOfMemoryError等，error是无法处理的。</p>
<p><strong>Exception:</strong> 代码异常，Java程序员关心的基类型通常是Exception。它能被程序本身可以处理，这也是它跟Error的区别。</p>
<p>它可以分为RuntimeException（运行时异常）和CheckedException（可检查的异常）。<br>常见的RuntimeException异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- NullPointerException 空指针异常</span><br><span class="line">- ArithmeticException 出现异常的运算条件时，抛出此异常</span><br><span class="line">- IndexOutOfBoundsException 数组索引越界异常</span><br><span class="line">- ClassNotFoundException 找不到类异常</span><br><span class="line">- IllegalArgumentException(非法参数异常)</span><br></pre></td></tr></table></figure>

<p>常见的 Checked Exception 异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- IOException (操作输入流和输出流时可能出现的异常)</span><br><span class="line">- ClassCastException(类型转换异常类)</span><br></pre></td></tr></table></figure>

<p>有兴趣可以看我之前写得这篇文章：<br><a target="_blank" rel="noopener" href="https://juejin.im/post/5dc68c0f51882528957fadb3">Java程序员必备：异常的十个关键知识点</a></p>
<h3 id="30-深拷贝和浅拷贝区别"><a href="#30-深拷贝和浅拷贝区别" class="headerlink" title="30. 深拷贝和浅拷贝区别"></a>30. 深拷贝和浅拷贝区别</h3><p><strong>浅拷贝</strong></p>
<p>复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化。<br><img src="https://user-gold-cdn.xitu.io/2020/2/1/16ffca9fd5f38501?w=1140&h=596&f=png&s=68287"></p>
<p><strong>深拷贝</strong></p>
<p>将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/1/16ffcab48469215e?w=1146&h=554&f=png&s=54807"></p>
<h3 id="31-JDK-和-JRE-有什么区别？"><a href="#31-JDK-和-JRE-有什么区别？" class="headerlink" title="31. JDK 和 JRE 有什么区别？"></a>31. JDK 和 JRE 有什么区别？</h3><ul>
<li>JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。</li>
<li>JRE：Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提供了所需环境。</li>
</ul>
<h3 id="32-String-类的常用方法都有那些呢？"><a href="#32-String-类的常用方法都有那些呢？" class="headerlink" title="32. String 类的常用方法都有那些呢？"></a>32. String 类的常用方法都有那些呢？</h3><ul>
<li>indexOf()：返回指定字符的索引。</li>
<li>charAt()：返回指定索引处的字符。</li>
<li>replace()：字符串替换。</li>
<li>trim()：去除字符串两端空白。</li>
<li>split()：分割字符串，返回一个分割后的字符串数组。</li>
<li>getBytes()：返回字符串的 byte 类型数组。</li>
<li>length()：返回字符串长度。</li>
<li>toLowerCase()：将字符串转成小写字母。</li>
<li>toUpperCase()：将字符串转成大写字符。</li>
<li>substring()：截取字符串。</li>
<li>equals()：字符串比较。</li>
</ul>
<h3 id="33-谈谈自定义注解的场景及实现"><a href="#33-谈谈自定义注解的场景及实现" class="headerlink" title="33. 谈谈自定义注解的场景及实现"></a>33. 谈谈自定义注解的场景及实现</h3><ul>
<li>之前我这边有这么一个业务场景，用Redis控制接口调用频率，有使用过自定义注解。</li>
<li>通过 AOP（动态代理机制）给方法添加切面，通过反射来获取方法包含的注解，如果包含自定义关键字注解，就通过Redis进行校验拦截请求。</li>
</ul>
<p>有关于注解，建议大家看一下java编程思想的注解篇章哈~</p>
<h3 id="34-说说你熟悉的设计模式有哪些？"><a href="#34-说说你熟悉的设计模式有哪些？" class="headerlink" title="34. 说说你熟悉的设计模式有哪些？"></a>34. 说说你熟悉的设计模式有哪些？</h3><p>设计模式分为三大类：</p>
<ul>
<li>创建型模式：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式（5种）</li>
<li>结构型模式：适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式。（7种）</li>
<li>行为型模式：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。（11种）</li>
</ul>
<p>最好平时积累一下，单例模式（7种实现方式），工厂模式，模板方法设计模式，策略模式，装饰者模式、代理模式这几种怎么写吧~</p>
<p>个人觉得，可以看看Hollis大神相关设计模式的文章哈，写得特别好！<a target="_blank" rel="noopener" href="http://www.hollischuang.com/archives/1373">设计模式（二）——单例模式</a></p>
<h3 id="35-抽象工厂和工厂方法模式的区别？"><a href="#35-抽象工厂和工厂方法模式的区别？" class="headerlink" title="35. 抽象工厂和工厂方法模式的区别？"></a>35. 抽象工厂和工厂方法模式的区别？</h3><p><img src="https://user-gold-cdn.xitu.io/2020/5/17/1722243c2208ae97?w=1231&h=321&f=png&s=33937"><br>可以看一下这篇文章介绍：<a target="_blank" rel="noopener" href="https://blog.csdn.net/wyxhd2008/article/details/5597975">抽象工厂模式-与-工厂方法模式区别</a></p>
<h3 id="36-什么是值传递和引用传递？"><a href="#36-什么是值传递和引用传递？" class="headerlink" title="36. 什么是值传递和引用传递？"></a>36. 什么是值传递和引用传递？</h3><ul>
<li>值传递是对基本型变量而言的,传递的是该变量的一个副本，改变副本不影响原变量.</li>
<li>引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。 所以对引用对象进行操作会同时改变原对象.</li>
</ul>
<h3 id="37-可以在static环境中访问非static变量吗？"><a href="#37-可以在static环境中访问非static变量吗？" class="headerlink" title="37. 可以在static环境中访问非static变量吗？"></a>37. 可以在static环境中访问非static变量吗？</h3><blockquote>
<p>static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。因为静态的成员属于类，随着类的加载而加载到静态方法区内存，当类加载时，此时不一定有实例创建，没有实例，就不可以访问非静态的成员。类的加载先于实例的创建，因此静态环境中，不可以访问非静态！</p>
</blockquote>
<h3 id="38-Java支持多继承么-为什么？"><a href="#38-Java支持多继承么-为什么？" class="headerlink" title="38. Java支持多继承么,为什么？"></a>38. Java支持多继承么,为什么？</h3><p>不支持多继承，原因:</p>
<ul>
<li>安全性的考虑，如果子类继承的多个父类里面有相同的方法或者属性，子类将不知道具体要继承哪个。</li>
<li>Java提供了接口和内部类以达到实现多继承功能，弥补单继承的缺陷。</li>
</ul>
<h3 id="39-用最有效率的方法计算2乘以8？"><a href="#39-用最有效率的方法计算2乘以8？" class="headerlink" title="39. 用最有效率的方法计算2乘以8？"></a>39. 用最有效率的方法计算2乘以8？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 &lt;&lt; 3</span><br></pre></td></tr></table></figure>
<ul>
<li>将一个数左移n位，就相当于这个数乘以了2的n次方。</li>
<li>那么，一个数乘以8只要将其左移3位即可。</li>
<li>而cpu直接支持位移运算，且效率最高。</li>
</ul>
<h3 id="40-构造器是否可被重写？"><a href="#40-构造器是否可被重写？" class="headerlink" title="40. 构造器是否可被重写？"></a>40. 构造器是否可被重写？</h3><p>构造器是不能被继承的，因为每个类的类名都不相同，而构造器名称与类名相同，所以谈不上继承。<br>又由于构造器不能被继承，所以相应的就不能被重写了。</p>
<h3 id="41-char型变量中能不能存贮一个中文汉字，为什么？"><a href="#41-char型变量中能不能存贮一个中文汉字，为什么？" class="headerlink" title="41. char型变量中能不能存贮一个中文汉字，为什么？"></a>41. char型变量中能不能存贮一个中文汉字，为什么？</h3><p> 在Java中，char类型占2个字节，而且Java默认采用Unicode编码，一个Unicode码是16位，所以一个Unicode码占两个字节，Java中无论汉子还是英文字母都是用Unicode编码来表示的。所以，在Java中，char类型变量可以存储一个中文汉字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char ch = &#x27;啦&#x27;;</span><br><span class="line">System.out.println(&quot;char:&quot; + ch);</span><br></pre></td></tr></table></figure>
<h3 id="42-如何实现对象克隆？"><a href="#42-如何实现对象克隆？" class="headerlink" title="42. 如何实现对象克隆？"></a>42. 如何实现对象克隆？</h3><ul>
<li>实现 Cloneable 接口，重写 clone() 方法。</li>
<li>Object 的 clone() 方法是浅拷贝，即如果类中属性有自定义引用类型，只拷贝引用，不拷贝引用指向的对象。</li>
<li>对象的属性的Class 也实现 Cloneable 接口，在克隆对象时也手动克隆属性，完成深拷贝</li>
<li>结合序列化(JDK java.io.Serializable 接口、JSON格式、XML格式等)，完成深拷贝</li>
</ul>
<h3 id="43-object中定义了哪些方法？"><a href="#43-object中定义了哪些方法？" class="headerlink" title="43. object中定义了哪些方法？"></a>43. object中定义了哪些方法？</h3><ul>
<li>getClass(); 获取类结构信息</li>
<li>hashCode() 获取哈希码</li>
<li>equals(Object) 默认比较对象的地址值是否相等，子类可以重写比较规则</li>
<li>clone() 用于对象克隆</li>
<li>toString() 把对象转变成字符串</li>
<li>notify() 多线程中唤醒功能</li>
<li>notifyAll() 多线程中唤醒所有等待线程的功能</li>
<li>wait()  让持有对象锁的线程进入等待</li>
<li>wait(long timeout) 让持有对象锁的线程进入等待，设置超时毫秒数时间</li>
<li>wait(long timeout, int nanos) 让持有对象锁的线程进入等待，设置超时纳秒数时间</li>
<li>finalize() 垃圾回收前执行的方法</li>
</ul>
<h3 id="44-hashCode的作用是什么？"><a href="#44-hashCode的作用是什么？" class="headerlink" title="44. hashCode的作用是什么？"></a>44. hashCode的作用是什么？</h3><blockquote>
<ul>
<li>hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的；</li>
<li>如果两个对象相同，就是适用于equals(java.lang.Object) 方法，那么这两个对象的hashCode一定要相同；</li>
<li>如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点；</li>
<li>两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中.</li>
</ul>
</blockquote>
<p>这篇文章讲得挺详细的：<a target="_blank" rel="noopener" href="https://blog.csdn.net/fenglibing/article/details/8905007">Java中hashCode的作用</a></p>
<h3 id="45-for-each与常规for循环的效率对比"><a href="#45-for-each与常规for循环的效率对比" class="headerlink" title="45. for-each与常规for循环的效率对比"></a>45. for-each与常规for循环的效率对比</h3><p>关于这个问题,《Effective Java》给我们做的解答：</p>
<blockquote>
<p>for-each能够让代码更加清晰，并且减少了出错的机会。 下面的惯用代码适用于集合与数组类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (Element e : elements) &#123;</span><br><span class="line">     doSomething(e); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用for-each循环与常规的for循环相比，并不存在性能损失，即使对数组进行迭代也是如此。实际上，在有些场合下它还能带来微小的性能提升，因为它只计算一次数组索引的上限。</p>
</blockquote>
<h3 id="46-写出几种单例模式实现，懒汉模式和饿汉模式区别"><a href="#46-写出几种单例模式实现，懒汉模式和饿汉模式区别" class="headerlink" title="46. 写出几种单例模式实现，懒汉模式和饿汉模式区别"></a>46. 写出几种单例模式实现，懒汉模式和饿汉模式区别</h3><p>7种：</p>
<ul>
<li>第一种（懒汉，线程不安全）</li>
<li>第二种（懒汉，线程安全）</li>
<li>第三种（饿汉）</li>
<li>第四种（饿汉，变种）</li>
<li>第五种（静态内部类）</li>
<li>第六种（枚举）：</li>
<li>第七种（双重校验锁）</li>
</ul>
<p>可以看这篇文章：<a target="_blank" rel="noopener" href="https://www.iteye.com/blog/cantellow-838473">单例模式的七种写法</a></p>
<h3 id="47-请列出-5-个运行时异常。"><a href="#47-请列出-5-个运行时异常。" class="headerlink" title="47. 请列出 5 个运行时异常。"></a>47. 请列出 5 个运行时异常。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- NullPointerException 空指针异常</span><br><span class="line">- ArithmeticException 出现异常的运算条件时，抛出此异常</span><br><span class="line">- IndexOutOfBoundsException 数组索引越界异常</span><br><span class="line">- ClassNotFoundException 找不到类异常</span><br><span class="line">- IllegalArgumentException(非法参数异常)</span><br></pre></td></tr></table></figure>
<h3 id="48-2个不相等的对象有可能具有相同的-hashcode吗？"><a href="#48-2个不相等的对象有可能具有相同的-hashcode吗？" class="headerlink" title="48. 2个不相等的对象有可能具有相同的 hashcode吗？"></a>48. 2个不相等的对象有可能具有相同的 hashcode吗？</h3><p>有可能哈~</p>
<p><strong>hashCode 的常规协定：</strong></p>
<ul>
<li>在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。</li>
<li>两个对象的equals()相等，那么对这两个对象中的每个对象调用 hashCode 方法都必须生成相同的整数结果。</li>
<li>两个对象的equals()不相等，那么对这两个对象中的任一对象上调用 hashCode 方法不要求一定生成不同的整数结果。但是，为不相等的对象生成不同整数结果可以提高哈希表的性能。</li>
</ul>
<h3 id="49-访问修饰符public-private-protected-以及default的区别？"><a href="#49-访问修饰符public-private-protected-以及default的区别？" class="headerlink" title="49. 访问修饰符public,private,protected,以及default的区别？"></a>49. 访问修饰符public,private,protected,以及default的区别？</h3><p><img src="https://user-gold-cdn.xitu.io/2020/5/17/172222190f5c2bf7?w=1232&h=276&f=png&s=23829"></p>
<h3 id="50-谈谈final在java中的作用？"><a href="#50-谈谈final在java中的作用？" class="headerlink" title="50. 谈谈final在java中的作用？"></a>50. 谈谈final在java中的作用？</h3><ul>
<li>final 修饰的类叫最终类，该类不能被继承。</li>
<li>final 修饰的方法不能被重写。</li>
<li>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</li>
</ul>
<h3 id="51-java中的Math-round-1-5-等于多少呢？"><a href="#51-java中的Math-round-1-5-等于多少呢？" class="headerlink" title="51. java中的Math.round(-1.5) 等于多少呢？"></a>51. java中的Math.round(-1.5) 等于多少呢？</h3><p><img src="https://user-gold-cdn.xitu.io/2020/5/17/172228be1252e870?w=847&h=394&f=png&s=44655"></p>
<p>JDK 中的 java.lang.Math 类:</p>
<ul>
<li>round() ：返回四舍五入，负 .5 小数返回较大整数，如 -1.5 返回 -1。</li>
<li>ceil() ：返回小数所在两整数间的较大值，如 -1.5 返回 -1.0。</li>
<li>floor() ：返回小数所在两整数间的较小值，如 -1.5 返回 -2.0。</li>
</ul>
<h3 id="52-String属于基础的数据类型吗？"><a href="#52-String属于基础的数据类型吗？" class="headerlink" title="52. String属于基础的数据类型吗？"></a>52. String属于基础的数据类型吗？</h3><p>String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。</p>
<h3 id="53-如何将字符串反转呢？"><a href="#53-如何将字符串反转呢？" class="headerlink" title="53. 如何将字符串反转呢？"></a>53. 如何将字符串反转呢？</h3><ul>
<li>使用 StringBuilder 或 StringBuffer 的 reverse 方法，本质都调用了它们的父类 AbstractStringBuilder 的 reverse 方法实现。（JDK1.8）</li>
<li>使用chatAt函数，倒过来输出；</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/17/1722295d9a7ea883?w=855&h=557&f=png&s=56301"></p>
<h3 id="54-描述动态代理的几种实现方式，它们分别有什么优缺点"><a href="#54-描述动态代理的几种实现方式，它们分别有什么优缺点" class="headerlink" title="54. 描述动态代理的几种实现方式，它们分别有什么优缺点"></a>54. 描述动态代理的几种实现方式，它们分别有什么优缺点</h3><ul>
<li>JDK动态代理</li>
<li>CGLIB动态代理</li>
<li>JDK原声动态代理时java原声支持的、不需要任何外部依赖、但是它只能基于接口进行代理</li>
<li>CGLIB通过继承的方式进行代理、无论目标对象没有没实现接口都可以代理，但是无法处理final的情况</li>
</ul>
<h3 id="55-在自己的代码中，如果创建一个java-lang-String类，这个类是否可以被类加载器加载？为什么。"><a href="#55-在自己的代码中，如果创建一个java-lang-String类，这个类是否可以被类加载器加载？为什么。" class="headerlink" title="55. 在自己的代码中，如果创建一个java.lang.String类，这个类是否可以被类加载器加载？为什么。"></a>55. 在自己的代码中，如果创建一个java.lang.String类，这个类是否可以被类加载器加载？为什么。</h3><p>不可以。因为JDK处于安全性的考虑，基于双亲委派模型，优先加载JDK的String类，如果java.lang.String已经加载，便不会再次被加载。</p>
<h3 id="56-谈谈你对java-lang-Object对象中hashCode和equals方法的理解。在什么场景下需要重新实现这两个方法。"><a href="#56-谈谈你对java-lang-Object对象中hashCode和equals方法的理解。在什么场景下需要重新实现这两个方法。" class="headerlink" title="56. 谈谈你对java.lang.Object对象中hashCode和equals方法的理解。在什么场景下需要重新实现这两个方法。"></a>56. 谈谈你对java.lang.Object对象中hashCode和equals方法的理解。在什么场景下需要重新实现这两个方法。</h3><blockquote>
<ul>
<li>在我们的业务系统中判断对象时有时候需要的不是一种严格意义上的相等，而是一种业务上的对象相等。在这种情况下，原生的equals方法就不能满足我们的需求了，所以这个时候我们需要重写equals方法，来满足我们的业务系统上的需求。</li>
<li>那么为什么在重写equals方法的时候需要重写hashCode方法呢？ 如果只重写了equals方法而没有重写hashCode方法的话，则会违反约定的第二条：相等的对象必须具有相等的散列码.所以hashCode和equals方法都需要重写</li>
</ul>
</blockquote>
<p>可以看网上这篇文章哈：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zknxx/article/details/53862572">java为什么要重写hashCode和equals方法</a></p>
<h3 id="57-在jdk1-5中，引入了泛型，泛型的存在是用来解决什么问题。"><a href="#57-在jdk1-5中，引入了泛型，泛型的存在是用来解决什么问题。" class="headerlink" title="57. 在jdk1.5中，引入了泛型，泛型的存在是用来解决什么问题。"></a>57. 在jdk1.5中，引入了泛型，泛型的存在是用来解决什么问题。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java 泛型（generics）是 JDK 5 中引入的一个新特性，其本质是参数化类型，解决不确定具体对象类型的问题。</span><br></pre></td></tr></table></figure>

<p>这个面试题，可以看我这篇文章哈~<a target="_blank" rel="noopener" href="https://juejin.im/post/5e1954c0f265da3e1e0568de">Java程序员必备基础：泛型解析</a></p>
<h3 id="58-什么是序列化，怎么序列化，反序列呢？"><a href="#58-什么是序列化，怎么序列化，反序列呢？" class="headerlink" title="58. 什么是序列化，怎么序列化，反序列呢？"></a>58. 什么是序列化，怎么序列化，反序列呢？</h3><ul>
<li>序列化：把Java对象转换为字节序列的过程</li>
<li>反序列：把字节序列恢复为Java对象的过程<br><img src="https://user-gold-cdn.xitu.io/2020/5/17/17222b156f8b230e?w=1280&h=487&f=png&s=189822"></li>
</ul>
<p>可以看我这篇文章哈~ <a target="_blank" rel="noopener" href="https://juejin.im/post/5e7f150d51882573b3309ceb">Java程序员必备：序列化全方位解析</a></p>
<h3 id="59-java8的新特性。"><a href="#59-java8的新特性。" class="headerlink" title="59. java8的新特性。"></a>59. java8的新特性。</h3><ul>
<li>Lambda 表达式：Lambda允许把函数作为一个方法的参数</li>
<li>Stream API ：新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中</li>
<li>方法引用：方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。</li>
<li>默认方法：默认方法就是一个在接口里面有了一个实现的方法。</li>
<li>Optional 类 ：Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</li>
<li>Date Time API ：加强对日期与时间的处理。</li>
</ul>
<h3 id="60-匿名内部类是什么？如何访问在其外面定义的变量呢？"><a href="#60-匿名内部类是什么？如何访问在其外面定义的变量呢？" class="headerlink" title="60. 匿名内部类是什么？如何访问在其外面定义的变量呢？"></a>60. 匿名内部类是什么？如何访问在其外面定义的变量呢？</h3><p>匿名内部类就是没有名字的内部类，日常开发中使用的比较多。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line"></span><br><span class="line">    private void test(final int i) &#123;</span><br><span class="line">        new Service() &#123;</span><br><span class="line">            public void method() &#123;</span><br><span class="line">                for (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">                    System.out.println(&quot;匿名内部类&quot; );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.method();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> //匿名内部类必须继承或实现一个已有的接口 </span><br><span class="line"> interface Service&#123;</span><br><span class="line">    void method();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>匿名内部类还有以下特点：</p>
<ul>
<li>没有名字</li>
<li>匿名内部类必须继承一个抽象类或者实现一个接口。</li>
<li>匿名内部类不能定义任何静态成员和静态方法。</li>
<li>当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。</li>
<li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</li>
<li>匿名内部类不能访问外部类方法中的局部变量，除非该变量被声明为final类型</li>
</ul>
<p>可以看我这篇文章哈~<a target="_blank" rel="noopener" href="https://juejin.im/post/5e105e1ef265da5d61695a45">Java程序员必备基础：内部类解析</a></p>
<h3 id="61-break和continue有什么区别？"><a href="#61-break和continue有什么区别？" class="headerlink" title="61. break和continue有什么区别？"></a>61. break和continue有什么区别？</h3><ul>
<li>break可以使流程跳出switch语句体，也可以在循环结构终止本层循环体，从而提前结束本层循环。</li>
<li>continue的作用是跳过本次循环体中余下尚未执行的语句，立即进行下一次的循环条件判定，可以理解为仅结束本次循环</li>
</ul>
<h3 id="62-String-s-x3D-“Hello”-s-x3D-s-“-world-”-这两行代码执行后，原始的-String-对象中的内容是否会改变？"><a href="#62-String-s-x3D-“Hello”-s-x3D-s-“-world-”-这两行代码执行后，原始的-String-对象中的内容是否会改变？" class="headerlink" title="62. String s &#x3D; “Hello”;s &#x3D; s + “ world!”;这两行代码执行后，原始的 String 对象中的内容是否会改变？"></a>62. String s &#x3D; “Hello”;s &#x3D; s + “ world!”;这两行代码执行后，原始的 String 对象中的内容是否会改变？</h3><p>没有。因为 String 被设计成不可变(immutable)类，所以它的所有对象都是不可变对象。</p>
<h3 id="63-String-s-x3D-”a”-”b”-”c”-”d”-创建了几个对象？"><a href="#63-String-s-x3D-”a”-”b”-”c”-”d”-创建了几个对象？" class="headerlink" title="63. String s&#x3D;”a”+”b”+”c”+”d”;创建了几个对象？"></a>63. String s&#x3D;”a”+”b”+”c”+”d”;创建了几个对象？</h3><p>1个而已啦。</p>
<blockquote>
<p>Java 编译器对字符串常量直接相加的表达式进行优化，不等到运行期去进行加法运算，在编译时就去掉了加号，直接将其编译成一个这些常量相连的结果。所以 “a”+”b”+”c”+”d” 相当于直接定义一个 “abcd” 的字符串。</p>
</blockquote>
<h3 id="64-try-catch-finally-return执行顺序"><a href="#64-try-catch-finally-return执行顺序" class="headerlink" title="64. try-catch-finally-return执行顺序"></a>64. try-catch-finally-return执行顺序</h3><p>try-catch-finally-return 执行描述:</p>
<ul>
<li>如果不发生异常，不会执行catch部分。</li>
<li>不管有没有发生异常，finally都会执行到。</li>
<li>即使try和catch中有return时，finally仍然会执行</li>
<li>finally是在return后面的表达式运算完后再执行的。（此时并没有返回运算后的值，而是先把要返回的值保存起来，若finally中无return，则不管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值），该情况下函数返回值是在finally执行前确定的)</li>
<li>finally部分就不要return了，要不然，就回不去try或者catch的return了。</li>
</ul>
<p>看一个例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">       System.out.println(&quot;result：&quot; + test());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private static int test() &#123;</span><br><span class="line">       int temp = 1;</span><br><span class="line">       try &#123;</span><br><span class="line">           System.out.println(&quot;start execute try,temp is:&quot;+temp);</span><br><span class="line">           return ++temp;</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           System.out.println(&quot;start execute catch temp is: &quot;+temp);</span><br><span class="line">           return ++temp;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           System.out.println(&quot;start execute finally,temp is:&quot; + temp);</span><br><span class="line">           ++temp;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start execute try,temp is:1</span><br><span class="line">start execute finally,temp is:2</span><br><span class="line">result:2</span><br></pre></td></tr></table></figure>
<p>分析：</p>
<ul>
<li>先执行try部分，输出日志，执行<code>++temp</code>表达式，temp变为2,这个值被保存起来。</li>
<li>因为没有发生异常，所以catch代码块跳过。</li>
<li>执行finally代码块，输出日志，执行<code>++temp</code>表达式.</li>
<li>返回try部分保存的值2.</li>
</ul>
<h3 id="65-Java-7新的-try-with-resources语句，平时有使用吗"><a href="#65-Java-7新的-try-with-resources语句，平时有使用吗" class="headerlink" title="65. Java 7新的 try-with-resources语句，平时有使用吗"></a>65. Java 7新的 try-with-resources语句，平时有使用吗</h3><p>try-with-resources，是Java7提供的一个新功能，它用于自动资源管理。</p>
<ul>
<li>资源是指在程序用完了之后必须要关闭的对象。</li>
<li>try-with-resources保证了每个声明了的资源在语句结束的时候会被关闭</li>
<li>什么样的对象才能当做资源使用呢？只要实现了java.lang.AutoCloseable接口或者java.io.Closeable接口的对象，都OK。</li>
</ul>
<p>在<code>try-with-resources</code>出现之前</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    //open resources like File, Database connection, Sockets etc</span><br><span class="line">&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">    // Exception handling like FileNotFoundException, IOException etc</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    // close resources</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java7，<code>try-with-resources</code>出现之后，使用资源实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try(// open resources here)&#123;</span><br><span class="line">    // use resources</span><br><span class="line">&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">    // exception handling</span><br><span class="line">&#125;</span><br><span class="line">// resources are closed as soon as try-catch block is executed.</span><br></pre></td></tr></table></figure>

<p>Java7使用资源demo</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Java7TryResourceTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try (BufferedReader br = new BufferedReader(new FileReader(</span><br><span class="line">                &quot;C:/jaywei.txt&quot;))) &#123;</span><br><span class="line">            System.out.println(br.readLine());</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用了<code>try-with-resources</code>的好处</p>
<ul>
<li>代码更加优雅，行数更少。</li>
<li>资源自动管理，不用担心内存泄漏问题。</li>
</ul>
<h3 id="66-简述一下面向对象的”六原则一法则”。"><a href="#66-简述一下面向对象的”六原则一法则”。" class="headerlink" title="66. 简述一下面向对象的”六原则一法则”。"></a>66. 简述一下面向对象的”六原则一法则”。</h3><ul>
<li>单一职责原则:一个类只做它该做的事情。</li>
<li>开闭原则：软件实体应当对扩展开放，对修改关闭。</li>
<li>依赖倒转原则：面向接口编程。</li>
<li>接口隔离原则：接口要小而专，绝不能大而全。</li>
<li>合成聚合复用原则：优先使用聚合或合成关系复用代码。</li>
<li>迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。</li>
</ul>
<h3 id="67-switch是否能作用在byte-上，是否能作用在long-上，是否能作用在String上？"><a href="#67-switch是否能作用在byte-上，是否能作用在long-上，是否能作用在String上？" class="headerlink" title="67. switch是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？"></a>67. switch是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？</h3><ul>
<li>switch可作用于char byte short int</li>
<li>switch可作用于char byte short int对应的包装类</li>
<li>switch不可作用于long double float boolean，以及他们的包装类</li>
</ul>
<h3 id="68-数组有没有length-方法？String有没有length-方法？"><a href="#68-数组有没有length-方法？String有没有length-方法？" class="headerlink" title="68. 数组有没有length()方法？String有没有length()方法？"></a>68. 数组有没有length()方法？String有没有length()方法？</h3><ul>
<li>数组没有length()方法，而是length；</li>
<li>String有length()方法</li>
</ul>
<h3 id="69-是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"><a href="#69-是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？" class="headerlink" title="69. 是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"></a>69. 是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？</h3><p>不可以。</p>
<ul>
<li>非static方法是要与对象实例息息相关的，必须在创建一个对象后，才可以在该对象上进行非static方法调用，而static方法跟类相关的，不需要创建对象，可以由类直接调用。</li>
<li>当一个static方法被调用时，可能还没有创建任何实例对象，如果从一个static方法中发出对非static方法的调用，那个非static方法是关联到哪个对象上的呢？这个逻辑是不成立的</li>
<li>因此，一个static方法内部不可以发出对非static方法的调用。</li>
</ul>
<h3 id="70-String-s-x3D-new-String-“jay”-创建了几个字符串对象？"><a href="#70-String-s-x3D-new-String-“jay”-创建了几个字符串对象？" class="headerlink" title="70. String s &#x3D; new String(“jay”);创建了几个字符串对象？"></a>70. String s &#x3D; new String(“jay”);创建了几个字符串对象？</h3><p>一个或两个</p>
<blockquote>
<ul>
<li>第一次调用 new String(“jay”); 时，会在堆内存中创建一个字符串对象，同时在字符串常量池中创建一个对象 “jay”</li>
<li>第二次调用 new String(“jay”); 时，只会在堆内存中创建一个字符串对象，指向之前在字符串常量池中创建的 “jay”</li>
</ul>
</blockquote>
<p>可以看老王这篇文章，很清晰~<br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIwOTE2MzU4NA==&mid=2247484162&idx=1&sn=ff743ff5c975a373036749490042a868&chksm=9779472da00ece3b6186d8ce8e79cd1503311327ad4b38f569ccd29a9d15dec065ff201480d2&token=815554431&lang=zh_CN#rd">别再问我 new 字符串创建了几个对象了！我来证明给你看！</a></p>
<h3 id="71-this和super关键字的作用"><a href="#71-this和super关键字的作用" class="headerlink" title="71. this和super关键字的作用"></a>71. this和super关键字的作用</h3><p>this：</p>
<ul>
<li>对象内部指代自身的引用</li>
<li>解决成员变量和局部变量同名问题</li>
<li>可以调用成员变量，不能调用局部变量</li>
<li>可以调用成员方法</li>
<li>在普通方法中可以省略 this</li>
<li>在静态方法当中不允许出现 this 关键字</li>
</ul>
<p>super：</p>
<ul>
<li>调用父类 的成员或者方法</li>
<li>调用父类的构造函数</li>
</ul>
<h3 id="72-我们能将int强制转换为-byte类型的变量吗？如果该值大于byte-类型的范围，将会出现什么现象？"><a href="#72-我们能将int强制转换为-byte类型的变量吗？如果该值大于byte-类型的范围，将会出现什么现象？" class="headerlink" title="72. 我们能将int强制转换为 byte类型的变量吗？如果该值大于byte 类型的范围，将会出现什么现象？"></a>72. 我们能将int强制转换为 byte类型的变量吗？如果该值大于byte 类型的范围，将会出现什么现象？</h3><p>可以，我们可以做强制转换，但是在Java中，int是32位，byte是8位，如果强制做转化，int类型的高24位将会被丢弃。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        int a =129;</span><br><span class="line">        byte b = (byte) a;</span><br><span class="line">        System.out.println(b);</span><br><span class="line">        int c =10;</span><br><span class="line">        byte d = (byte) c;</span><br><span class="line">        System.out.println(d);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">-127</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<h3 id="73-float-f-x3D-3-4-正确吗？"><a href="#73-float-f-x3D-3-4-正确吗？" class="headerlink" title="73. float f&#x3D;3.4;正确吗？"></a>73. float f&#x3D;3.4;正确吗？</h3><p>不正确，精度不准确,应该用强制类型转换<br><img src="https://user-gold-cdn.xitu.io/2020/5/17/17222ee41ca4cc4c?w=466&h=125&f=png&s=8438"></p>
<h3 id="74-接口可否继承接口？抽象类是否可实现接口？抽象类是否可继承实体类？"><a href="#74-接口可否继承接口？抽象类是否可实现接口？抽象类是否可继承实体类？" class="headerlink" title="74. 接口可否继承接口？抽象类是否可实现接口？抽象类是否可继承实体类？"></a>74. 接口可否继承接口？抽象类是否可实现接口？抽象类是否可继承实体类？</h3><p>都可以的</p>
<h3 id="75-Reader和InputStream区别？"><a href="#75-Reader和InputStream区别？" class="headerlink" title="75. Reader和InputStream区别？"></a>75. Reader和InputStream区别？</h3><ul>
<li>InputStream是表示字节输入流的所有类的超类</li>
<li>Reader是用于读取字符流的抽象类</li>
</ul>
<h3 id="76-列举出JAVA中6个比较常用的包"><a href="#76-列举出JAVA中6个比较常用的包" class="headerlink" title="76. 列举出JAVA中6个比较常用的包"></a>76. 列举出JAVA中6个比较常用的包</h3><ul>
<li>java.lang;</li>
<li>java.util;</li>
<li>java.io;</li>
<li>java.sql;</li>
<li>java.awt;</li>
<li>java.net;</li>
</ul>
<h3 id="77-JDK-7有哪些新特性"><a href="#77-JDK-7有哪些新特性" class="headerlink" title="77.  JDK 7有哪些新特性"></a>77.  JDK 7有哪些新特性</h3><ul>
<li>Try-with-resource语句 </li>
<li>NIO2 文件处理Files</li>
<li>switch可以支持字符串判断条件</li>
<li>泛型推导</li>
<li>多异常统一处理</li>
</ul>
<h3 id="78-同步和异步有什么区别？"><a href="#78-同步和异步有什么区别？" class="headerlink" title="78. 同步和异步有什么区别？"></a>78. 同步和异步有什么区别？</h3><ul>
<li>同步，可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是出于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。</li>
<li>异步，执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。</li>
<li>同步，就是实时处理（如打电话）</li>
<li>异步，就是分时处理（如收发短信）</li>
</ul>
<p>参考这篇文章~ <a target="_blank" rel="noopener" href="https://blog.csdn.net/tennysonsky/article/details/45111623">同步和异步的区别</a></p>
<h3 id="79-实际开发中，Java一般使用什么数据类型来代表价格？"><a href="#79-实际开发中，Java一般使用什么数据类型来代表价格？" class="headerlink" title="79. 实际开发中，Java一般使用什么数据类型来代表价格？"></a>79. 实际开发中，Java一般使用什么数据类型来代表价格？</h3><p>java中使用BigDecimal来表示价格是比较好的。</p>
<p>可以看这篇文章，写得非常好<br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247485507&idx=1&sn=5c65f4a62ceab57a23bfe810a161035b&chksm=fddede87caa957918b6c131440c2c7aba5b21d72b296588776c6b85b6f8934bb4b6bfda97858&token=815554431&lang=zh_CN#rd">老大说：谁要再用double定义商品金额，就自己收拾东西走</a></p>
<h3 id="80-64-位-JVM-中，int-的长度是多数？"><a href="#80-64-位-JVM-中，int-的长度是多数？" class="headerlink" title="80. 64 位 JVM 中，int 的长度是多数？"></a>80. 64 位 JVM 中，int 的长度是多数？</h3><p>int数据类型占4个字节 32位，跟JVM位数没关系的</p>
<h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p><img src="https://user-gold-cdn.xitu.io/2020/5/16/1721b50d00331393?w=900&h=500&f=png&s=389569"></p>
<ul>
<li>欢迎关注我个人公众号，交个朋友，一起学习哈~</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">woaker</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/06/19/JavaHome/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E7%BB%93%E5%8F%B7/java%20%E5%9F%BA%E7%A1%80/1-80%E9%A2%98%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90/">http://example.com/2022/06/19/JavaHome/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E7%BB%93%E5%8F%B7/java%20%E5%9F%BA%E7%A1%80/1-80%E9%A2%98%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">每天都不一样</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/image/15.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/06/19/JavaHome/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E7%BB%93%E5%8F%B7/dubbo/dubbo%E9%9D%A2%E8%AF%95%E9%A2%98/dubbo%E9%9D%A2%E8%AF%95%E9%A2%98/"><img class="prev-cover" src="/image/15.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2022/06/19/JavaHome/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E7%BB%93%E5%8F%B7/Java%20%E5%B9%B6%E5%8F%91%20&amp;&amp;%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E4%B8%AA%E4%BA%BA%E7%8F%8D%E8%97%8F%E7%9A%8480%E9%81%93%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8811-20%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90%EF%BC%89/"><img class="next-cover" src="https://t7.baidu.com/it/u=1723468391,764687099&amp;fm=193&amp;f=GIF" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">woaker</div><div class="author-info__description">不积跬步无以至千里</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">194</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/woaker"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text">Java 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-equals%E4%B8%8E-x3D-x3D-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.</span> <span class="toc-text">1. equals与&#x3D;&#x3D;的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-final-finally-finalize-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.</span> <span class="toc-text">2. final, finally, finalize 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.3.</span> <span class="toc-text">3. 重载和重写的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84hashCode-%E7%9B%B8%E5%90%8C%EF%BC%8C%E5%88%99-equals-%E6%98%AF%E5%90%A6%E4%B9%9F%E4%B8%80%E5%AE%9A%E4%B8%BA-true%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">4. 两个对象的hashCode()相同，则 equals()是否也一定为 true？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">2.5.</span> <span class="toc-text">5. 抽象类和接口有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-BIO%E3%80%81NIO%E3%80%81AIO-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.6.</span> <span class="toc-text">6. BIO、NIO、AIO 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-String%EF%BC%8CStringbuffer%EF%BC%8CStringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.7.</span> <span class="toc-text">7. String，Stringbuffer，StringBuilder的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-JAVA%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%90%84%E8%87%AA%E5%8D%A0%E7%94%A8%E5%A4%9A%E5%B0%91%E5%AD%97%E8%8A%82%E5%91%A2"><span class="toc-number">2.8.</span> <span class="toc-text">8. JAVA中的几种基本数据类型是什么，各自占用多少字节呢</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-Comparator%E4%B8%8EComparable%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.9.</span> <span class="toc-text">9. Comparator与Comparable有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-String%E7%B1%BB%E8%83%BD%E8%A2%AB%E7%BB%A7%E6%89%BF%E5%90%97%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E3%80%82"><span class="toc-number">2.10.</span> <span class="toc-text">10. String类能被继承吗，为什么。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E8%AF%B4%E8%AF%B4Java%E4%B8%AD%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.11.</span> <span class="toc-text">11. 说说Java中多态的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-Java%E6%B3%9B%E5%9E%8B%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="toc-number">2.12.</span> <span class="toc-text">12. Java泛型和类型擦除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-int%E5%92%8CInteger-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E8%BF%98%E6%9C%89Integer%E7%BC%93%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.13.</span> <span class="toc-text">13. int和Integer 有什么区别，还有Integer缓存的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E8%AF%B4%E8%AF%B4%E5%8F%8D%E5%B0%84%E7%9A%84%E7%94%A8%E9%80%94%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%8CJava%E8%8E%B7%E5%8F%96%E5%8F%8D%E5%B0%84%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">2.14.</span> <span class="toc-text">14. 说说反射的用途及实现原理，Java获取反射的三种方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">2.15.</span> <span class="toc-text">15. 面向对象的特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-amp-%E5%92%8C-amp-amp-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.16.</span> <span class="toc-text">16. &amp;和&amp;&amp;的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-Java%E4%B8%ADIO%E6%B5%81%E5%88%86%E4%B8%BA%E5%87%A0%E7%A7%8D"><span class="toc-number">2.17.</span> <span class="toc-text">17. Java中IO流分为几种?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E8%AE%B2%E8%AE%B2%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%EF%BC%8C%E6%AF%94%E5%A6%82%E7%88%B6%E7%B1%BB%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8C%E5%AD%90%E7%B1%BB%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%82"><span class="toc-number">2.18.</span> <span class="toc-text">18. 讲讲类的实例化顺序，比如父类静态数据，构造函数，子类静态数据，构造函数。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">2.19.</span> <span class="toc-text">19. Java创建对象有几种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E5%A6%82%E4%BD%95%E5%B0%86GB2312%E7%BC%96%E7%A0%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BAISO-8859-1%E7%BC%96%E7%A0%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%91%A2%EF%BC%9F"><span class="toc-number">2.20.</span> <span class="toc-text">20. 如何将GB2312编码的字符串转换为ISO-8859-1编码的字符串呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.21.</span> <span class="toc-text">21. 守护线程是什么？用什么方法实现守护线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-notify-%E5%92%8C-notifyAll-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.22.</span> <span class="toc-text">22. notify()和 notifyAll()有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-Java%E8%AF%AD%E8%A8%80%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E7%9A%84%EF%BC%8C%E5%85%B3%E9%94%AE%E5%AD%97throws%E3%80%81throw%E3%80%81try%E3%80%81catch%E3%80%81finally%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">2.23.</span> <span class="toc-text">23. Java语言是如何处理异常的，关键字throws、throw、try、catch、finally怎么使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E8%B0%88%E8%B0%88Java%E7%9A%84%E5%BC%82%E5%B8%B8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">2.24.</span> <span class="toc-text">24. 谈谈Java的异常层次结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%8E%E9%9D%9E%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">2.25.</span> <span class="toc-text">25. 静态内部类与非静态内部类有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-String-s%E4%B8%8Enew-String%E4%B8%8E%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">2.26.</span> <span class="toc-text">26. String s与new String与有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E5%8F%8D%E5%B0%84%E4%B8%AD%EF%BC%8CClass-forName%E5%92%8CClassLoader%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.27.</span> <span class="toc-text">27. 反射中，Class.forName和ClassLoader的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8Ecglib%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.28.</span> <span class="toc-text">28. JDK动态代理与cglib实现的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-error%E5%92%8Cexception%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8CCheckedException%EF%BC%8CRuntimeException%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="toc-number">2.29.</span> <span class="toc-text">29. error和exception的区别，CheckedException，RuntimeException的区别。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB"><span class="toc-number">2.30.</span> <span class="toc-text">30. 深拷贝和浅拷贝区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-JDK-%E5%92%8C-JRE-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.31.</span> <span class="toc-text">31. JDK 和 JRE 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-String-%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E9%83%BD%E6%9C%89%E9%82%A3%E4%BA%9B%E5%91%A2%EF%BC%9F"><span class="toc-number">2.32.</span> <span class="toc-text">32. String 类的常用方法都有那些呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%E8%B0%88%E8%B0%88%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%9C%BA%E6%99%AF%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.33.</span> <span class="toc-text">33. 谈谈自定义注解的场景及实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E7%86%9F%E6%82%89%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.34.</span> <span class="toc-text">34. 说说你熟悉的设计模式有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E5%92%8C%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.35.</span> <span class="toc-text">35. 抽象工厂和工厂方法模式的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-%E4%BB%80%E4%B9%88%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%EF%BC%9F"><span class="toc-number">2.36.</span> <span class="toc-text">36. 什么是值传递和引用传递？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-%E5%8F%AF%E4%BB%A5%E5%9C%A8static%E7%8E%AF%E5%A2%83%E4%B8%AD%E8%AE%BF%E9%97%AE%E9%9D%9Estatic%E5%8F%98%E9%87%8F%E5%90%97%EF%BC%9F"><span class="toc-number">2.37.</span> <span class="toc-text">37. 可以在static环境中访问非static变量吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38-Java%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B9%88-%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.38.</span> <span class="toc-text">38. Java支持多继承么,为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-%E7%94%A8%E6%9C%80%E6%9C%89%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%A1%E7%AE%972%E4%B9%98%E4%BB%A58%EF%BC%9F"><span class="toc-number">2.39.</span> <span class="toc-text">39. 用最有效率的方法计算2乘以8？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-%E6%9E%84%E9%80%A0%E5%99%A8%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A2%AB%E9%87%8D%E5%86%99%EF%BC%9F"><span class="toc-number">2.40.</span> <span class="toc-text">40. 构造器是否可被重写？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41-char%E5%9E%8B%E5%8F%98%E9%87%8F%E4%B8%AD%E8%83%BD%E4%B8%8D%E8%83%BD%E5%AD%98%E8%B4%AE%E4%B8%80%E4%B8%AA%E4%B8%AD%E6%96%87%E6%B1%89%E5%AD%97%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.41.</span> <span class="toc-text">41. char型变量中能不能存贮一个中文汉字，为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86%EF%BC%9F"><span class="toc-number">2.42.</span> <span class="toc-text">42. 如何实现对象克隆？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43-object%E4%B8%AD%E5%AE%9A%E4%B9%89%E4%BA%86%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">2.43.</span> <span class="toc-text">43. object中定义了哪些方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-hashCode%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.44.</span> <span class="toc-text">44. hashCode的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-for-each%E4%B8%8E%E5%B8%B8%E8%A7%84for%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%95%88%E7%8E%87%E5%AF%B9%E6%AF%94"><span class="toc-number">2.45.</span> <span class="toc-text">45. for-each与常规for循环的效率对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-%E5%86%99%E5%87%BA%E5%87%A0%E7%A7%8D%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%EF%BC%8C%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%A5%BF%E6%B1%89%E6%A8%A1%E5%BC%8F%E5%8C%BA%E5%88%AB"><span class="toc-number">2.46.</span> <span class="toc-text">46. 写出几种单例模式实现，懒汉模式和饿汉模式区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-%E8%AF%B7%E5%88%97%E5%87%BA-5-%E4%B8%AA%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E3%80%82"><span class="toc-number">2.47.</span> <span class="toc-text">47. 请列出 5 个运行时异常。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48-2%E4%B8%AA%E4%B8%8D%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%8F%AF%E8%83%BD%E5%85%B7%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84-hashcode%E5%90%97%EF%BC%9F"><span class="toc-number">2.48.</span> <span class="toc-text">48. 2个不相等的对象有可能具有相同的 hashcode吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49-%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6public-private-protected-%E4%BB%A5%E5%8F%8Adefault%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.49.</span> <span class="toc-text">49. 访问修饰符public,private,protected,以及default的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#50-%E8%B0%88%E8%B0%88final%E5%9C%A8java%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">2.50.</span> <span class="toc-text">50. 谈谈final在java中的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#51-java%E4%B8%AD%E7%9A%84Math-round-1-5-%E7%AD%89%E4%BA%8E%E5%A4%9A%E5%B0%91%E5%91%A2%EF%BC%9F"><span class="toc-number">2.51.</span> <span class="toc-text">51. java中的Math.round(-1.5) 等于多少呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52-String%E5%B1%9E%E4%BA%8E%E5%9F%BA%E7%A1%80%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%90%97%EF%BC%9F"><span class="toc-number">2.52.</span> <span class="toc-text">52. String属于基础的数据类型吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53-%E5%A6%82%E4%BD%95%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8D%E8%BD%AC%E5%91%A2%EF%BC%9F"><span class="toc-number">2.53.</span> <span class="toc-text">53. 如何将字符串反转呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#54-%E6%8F%8F%E8%BF%B0%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%AE%83%E4%BB%AC%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.54.</span> <span class="toc-text">54. 描述动态代理的几种实现方式，它们分别有什么优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#55-%E5%9C%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAjava-lang-String%E7%B1%BB%EF%BC%8C%E8%BF%99%E4%B8%AA%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8A%A0%E8%BD%BD%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E3%80%82"><span class="toc-number">2.55.</span> <span class="toc-text">55. 在自己的代码中，如果创建一个java.lang.String类，这个类是否可以被类加载器加载？为什么。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#56-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9java-lang-Object%E5%AF%B9%E8%B1%A1%E4%B8%ADhashCode%E5%92%8Cequals%E6%96%B9%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3%E3%80%82%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E9%9C%80%E8%A6%81%E9%87%8D%E6%96%B0%E5%AE%9E%E7%8E%B0%E8%BF%99%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%B3%95%E3%80%82"><span class="toc-number">2.56.</span> <span class="toc-text">56. 谈谈你对java.lang.Object对象中hashCode和equals方法的理解。在什么场景下需要重新实现这两个方法。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#57-%E5%9C%A8jdk1-5%E4%B8%AD%EF%BC%8C%E5%BC%95%E5%85%A5%E4%BA%86%E6%B3%9B%E5%9E%8B%EF%BC%8C%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%AD%98%E5%9C%A8%E6%98%AF%E7%94%A8%E6%9D%A5%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E3%80%82"><span class="toc-number">2.57.</span> <span class="toc-text">57. 在jdk1.5中，引入了泛型，泛型的存在是用来解决什么问题。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#58-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%8C%E6%80%8E%E4%B9%88%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%91%A2%EF%BC%9F"><span class="toc-number">2.58.</span> <span class="toc-text">58. 什么是序列化，怎么序列化，反序列呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#59-java8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E3%80%82"><span class="toc-number">2.59.</span> <span class="toc-text">59. java8的新特性。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#60-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E5%9C%A8%E5%85%B6%E5%A4%96%E9%9D%A2%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8F%98%E9%87%8F%E5%91%A2%EF%BC%9F"><span class="toc-number">2.60.</span> <span class="toc-text">60. 匿名内部类是什么？如何访问在其外面定义的变量呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#61-break%E5%92%8Ccontinue%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.61.</span> <span class="toc-text">61. break和continue有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62-String-s-x3D-%E2%80%9CHello%E2%80%9D-s-x3D-s-%E2%80%9C-world-%E2%80%9D-%E8%BF%99%E4%B8%A4%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%90%8E%EF%BC%8C%E5%8E%9F%E5%A7%8B%E7%9A%84-String-%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9%E6%98%AF%E5%90%A6%E4%BC%9A%E6%94%B9%E5%8F%98%EF%BC%9F"><span class="toc-number">2.62.</span> <span class="toc-text">62. String s &#x3D; “Hello”;s &#x3D; s + “ world!”;这两行代码执行后，原始的 String 对象中的内容是否会改变？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#63-String-s-x3D-%E2%80%9Da%E2%80%9D-%E2%80%9Db%E2%80%9D-%E2%80%9Dc%E2%80%9D-%E2%80%9Dd%E2%80%9D-%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">2.63.</span> <span class="toc-text">63. String s&#x3D;”a”+”b”+”c”+”d”;创建了几个对象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64-try-catch-finally-return%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">2.64.</span> <span class="toc-text">64. try-catch-finally-return执行顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#65-Java-7%E6%96%B0%E7%9A%84-try-with-resources%E8%AF%AD%E5%8F%A5%EF%BC%8C%E5%B9%B3%E6%97%B6%E6%9C%89%E4%BD%BF%E7%94%A8%E5%90%97"><span class="toc-number">2.65.</span> <span class="toc-text">65. Java 7新的 try-with-resources语句，平时有使用吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#66-%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E2%80%9D%E5%85%AD%E5%8E%9F%E5%88%99%E4%B8%80%E6%B3%95%E5%88%99%E2%80%9D%E3%80%82"><span class="toc-number">2.66.</span> <span class="toc-text">66. 简述一下面向对象的”六原则一法则”。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#67-switch%E6%98%AF%E5%90%A6%E8%83%BD%E4%BD%9C%E7%94%A8%E5%9C%A8byte-%E4%B8%8A%EF%BC%8C%E6%98%AF%E5%90%A6%E8%83%BD%E4%BD%9C%E7%94%A8%E5%9C%A8long-%E4%B8%8A%EF%BC%8C%E6%98%AF%E5%90%A6%E8%83%BD%E4%BD%9C%E7%94%A8%E5%9C%A8String%E4%B8%8A%EF%BC%9F"><span class="toc-number">2.67.</span> <span class="toc-text">67. switch是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#68-%E6%95%B0%E7%BB%84%E6%9C%89%E6%B2%A1%E6%9C%89length-%E6%96%B9%E6%B3%95%EF%BC%9FString%E6%9C%89%E6%B2%A1%E6%9C%89length-%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">2.68.</span> <span class="toc-text">68. 数组有没有length()方法？String有没有length()方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#69-%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E4%BB%8E%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%EF%BC%88static%EF%BC%89%E6%96%B9%E6%B3%95%E5%86%85%E9%83%A8%E5%8F%91%E5%87%BA%E5%AF%B9%E9%9D%9E%E9%9D%99%E6%80%81%EF%BC%88non-static%EF%BC%89%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="toc-number">2.69.</span> <span class="toc-text">69. 是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#70-String-s-x3D-new-String-%E2%80%9Cjay%E2%80%9D-%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">2.70.</span> <span class="toc-text">70. String s &#x3D; new String(“jay”);创建了几个字符串对象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#71-this%E5%92%8Csuper%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.71.</span> <span class="toc-text">71. this和super关键字的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#72-%E6%88%91%E4%BB%AC%E8%83%BD%E5%B0%86int%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%BA-byte%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F%E5%90%97%EF%BC%9F%E5%A6%82%E6%9E%9C%E8%AF%A5%E5%80%BC%E5%A4%A7%E4%BA%8Ebyte-%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%8C%83%E5%9B%B4%EF%BC%8C%E5%B0%86%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E7%8E%B0%E8%B1%A1%EF%BC%9F"><span class="toc-number">2.72.</span> <span class="toc-text">72. 我们能将int强制转换为 byte类型的变量吗？如果该值大于byte 类型的范围，将会出现什么现象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#73-float-f-x3D-3-4-%E6%AD%A3%E7%A1%AE%E5%90%97%EF%BC%9F"><span class="toc-number">2.73.</span> <span class="toc-text">73. float f&#x3D;3.4;正确吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#74-%E6%8E%A5%E5%8F%A3%E5%8F%AF%E5%90%A6%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3%EF%BC%9F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%EF%BC%9F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E7%BB%A7%E6%89%BF%E5%AE%9E%E4%BD%93%E7%B1%BB%EF%BC%9F"><span class="toc-number">2.74.</span> <span class="toc-text">74. 接口可否继承接口？抽象类是否可实现接口？抽象类是否可继承实体类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#75-Reader%E5%92%8CInputStream%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.75.</span> <span class="toc-text">75. Reader和InputStream区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#76-%E5%88%97%E4%B8%BE%E5%87%BAJAVA%E4%B8%AD6%E4%B8%AA%E6%AF%94%E8%BE%83%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8C%85"><span class="toc-number">2.76.</span> <span class="toc-text">76. 列举出JAVA中6个比较常用的包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#77-JDK-7%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">2.77.</span> <span class="toc-text">77.  JDK 7有哪些新特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#78-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.78.</span> <span class="toc-text">78. 同步和异步有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#79-%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E4%B8%AD%EF%BC%8CJava%E4%B8%80%E8%88%AC%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9D%A5%E4%BB%A3%E8%A1%A8%E4%BB%B7%E6%A0%BC%EF%BC%9F"><span class="toc-number">2.79.</span> <span class="toc-text">79. 实际开发中，Java一般使用什么数据类型来代表价格？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#80-64-%E4%BD%8D-JVM-%E4%B8%AD%EF%BC%8Cint-%E7%9A%84%E9%95%BF%E5%BA%A6%E6%98%AF%E5%A4%9A%E6%95%B0%EF%BC%9F"><span class="toc-number">2.80.</span> <span class="toc-text">80. 64 位 JVM 中，int 的长度是多数？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AC%E4%BC%97%E5%8F%B7"><span class="toc-number">3.</span> <span class="toc-text">公众号</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/07/02/advanced-java/docs/micro-services/microservices-introduction/" title="微服务"><img src="/image/12.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="微服务"/></a><div class="content"><a class="title" href="/2022/07/02/advanced-java/docs/micro-services/microservices-introduction/" title="微服务">微服务</a><time datetime="2022-07-02T01:48:10.973Z" title="发表于 2022-07-02 09:48:10">2022-07-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/02/advanced-java/docs/high-concurrency/why-cache/" title="缓存是如何使用"><img src="/image/11.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="缓存是如何使用"/></a><div class="content"><a class="title" href="/2022/07/02/advanced-java/docs/high-concurrency/why-cache/" title="缓存是如何使用">缓存是如何使用</a><time datetime="2022-07-02T01:48:10.969Z" title="发表于 2022-07-02 09:48:10">2022-07-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/02/advanced-java/docs/high-concurrency/why-mq/" title="消息队列"><img src="/image/10.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="消息队列"/></a><div class="content"><a class="title" href="/2022/07/02/advanced-java/docs/high-concurrency/why-mq/" title="消息队列">消息队列</a><time datetime="2022-07-02T01:48:10.969Z" title="发表于 2022-07-02 09:48:10">2022-07-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/02/advanced-java/docs/high-concurrency/redis-master-slave/" title="Redis 主从架构"><img src="/image/9.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis 主从架构"/></a><div class="content"><a class="title" href="/2022/07/02/advanced-java/docs/high-concurrency/redis-master-slave/" title="Redis 主从架构">Redis 主从架构</a><time datetime="2022-07-02T01:48:10.968Z" title="发表于 2022-07-02 09:48:10">2022-07-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/02/advanced-java/docs/high-concurrency/redis-persistence/" title="redis 的持久化有哪几种方式"><img src="/image/9.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="redis 的持久化有哪几种方式"/></a><div class="content"><a class="title" href="/2022/07/02/advanced-java/docs/high-concurrency/redis-persistence/" title="redis 的持久化有哪几种方式">redis 的持久化有哪几种方式</a><time datetime="2022-07-02T01:48:10.968Z" title="发表于 2022-07-02 09:48:10">2022-07-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By woaker</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>